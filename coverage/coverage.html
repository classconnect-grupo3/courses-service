
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">courses-service/src/config/config.go (100.0%)</option>
				
				<option value="file1">courses-service/src/controller/assignments_controller.go (100.0%)</option>
				
				<option value="file2">courses-service/src/controller/courses_controller.go (100.0%)</option>
				
				<option value="file3">courses-service/src/controller/enrollment_controller.go (97.5%)</option>
				
				<option value="file4">courses-service/src/controller/module_controller.go (100.0%)</option>
				
				<option value="file5">courses-service/src/controller/submission_controller.go (91.2%)</option>
				
				<option value="file6">courses-service/src/database/connection.go (71.4%)</option>
				
				<option value="file7">courses-service/src/docs/docs.go (0.0%)</option>
				
				<option value="file8">courses-service/src/main.go (0.0%)</option>
				
				<option value="file9">courses-service/src/middleware/student_auth.go (10.0%)</option>
				
				<option value="file10">courses-service/src/middleware/teacher_auth.go (10.0%)</option>
				
				<option value="file11">courses-service/src/repository/assignment_repository.go (87.0%)</option>
				
				<option value="file12">courses-service/src/repository/course_repository.go (82.4%)</option>
				
				<option value="file13">courses-service/src/repository/enrollment_repository.go (81.4%)</option>
				
				<option value="file14">courses-service/src/repository/module_repository.go (89.9%)</option>
				
				<option value="file15">courses-service/src/repository/submission_repository.go (83.3%)</option>
				
				<option value="file16">courses-service/src/router/router.go (96.3%)</option>
				
				<option value="file17">courses-service/src/service/assignment_service.go (100.0%)</option>
				
				<option value="file18">courses-service/src/service/course_service.go (95.0%)</option>
				
				<option value="file19">courses-service/src/service/enrollment_service.go (96.2%)</option>
				
				<option value="file20">courses-service/src/service/module_service.go (100.0%)</option>
				
				<option value="file21">courses-service/src/service/submission_service.go (53.2%)</option>
				
				<option value="file22">courses-service/src/tests/testutil/db_setup.go (72.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import "os"

type Config struct {
        DBUsername  string
        DBPassword  string
        DBName      string
        DBURI       string
        Host        string
        Port        string
        Environment string
}

func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DBUsername:  os.Getenv("DB_USERNAME"),
                DBPassword:  os.Getenv("DB_PASSWORD"),
                DBName:      os.Getenv("DB_NAME"),
                DBURI:       os.Getenv("DB_URI"),
                Host:        os.Getenv("HOST"),
                Port:        os.Getenv("PORT"),
                Environment: os.Getenv("ENVIRONMENT"),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "log/slog"
        "net/http"

        "courses-service/src/schemas"
        "courses-service/src/service"

        "github.com/gin-gonic/gin"
)

type AssignmentsController struct {
        service service.AssignmentServiceInterface
}

func NewAssignmentsController(service service.AssignmentServiceInterface) *AssignmentsController <span class="cov8" title="1">{
        return &amp;AssignmentsController{service: service}
}</span>

// @Summary Get all assignments
// @Description Get all assignments
// @Tags assignments
// @Accept json
// @Produce json
// @Router /assignments [get]
// @Success 200 {array} model.Assignment
func (c *AssignmentsController) GetAssignments(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting assignments")

        assignments, err := c.service.GetAssignments()
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting assignments", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignments retrieved", "assignments", assignments)
        ctx.JSON(http.StatusOK, assignments)</span>
}

// @Summary Create an assignment
// @Description Create an assignment
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignment body schemas.CreateAssignmentRequest true "Assignment to create"
// @Success 201 {object} model.Assignment
// @Router /assignments [post]
func (c *AssignmentsController) CreateAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating assignment")

        var assignment schemas.CreateAssignmentRequest
        if err := ctx.ShouldBindJSON(&amp;assignment); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">createdAssignment, err := c.service.CreateAssignment(assignment)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating assignment", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignment created", "assignment", createdAssignment)
        ctx.JSON(http.StatusCreated, createdAssignment)</span>
}

// @Summary Get an assignment by ID
// @Description Get an assignment by ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Success 200 {object} model.Assignment
// @Router /assignments/{assignmentId} [get]
func (c *AssignmentsController) GetAssignmentById(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting assignment by ID")
        id := ctx.Param("assignmentId")

        assignment, err := c.service.GetAssignmentById(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting assignment", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if assignment == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "assignment not found"})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignment retrieved", "assignment", assignment)
        ctx.JSON(http.StatusOK, assignment)</span>
}

// @Summary Get assignments by course ID
// @Description Get assignments by course ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param courseId path string true "Course ID"
// @Success 200 {array} model.Assignment
// @Router /assignments/course/{courseId} [get]
func (c *AssignmentsController) GetAssignmentsByCourseId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting assignments by course ID")
        courseId := ctx.Param("courseId")

        assignments, err := c.service.GetAssignmentsByCourseId(courseId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting assignments", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignments retrieved", "assignments", assignments)
        ctx.JSON(http.StatusOK, assignments)</span>
}

// @Summary Update an assignment
// @Description Update an assignment by ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param assignment body schemas.UpdateAssignmentRequest true "Assignment to update"
// @Success 200 {object} model.Assignment
// @Router /assignments/{assignmentId} [put]
func (c *AssignmentsController) UpdateAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating assignment")
        id := ctx.Param("assignmentId")

        var updateAssignmentRequest schemas.UpdateAssignmentRequest
        if err := ctx.ShouldBindJSON(&amp;updateAssignmentRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">updatedAssignment, err := c.service.UpdateAssignment(id, updateAssignmentRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating assignment", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignment updated", "assignment", updatedAssignment)
        ctx.JSON(http.StatusOK, updatedAssignment)</span>
}

// @Summary Delete an assignment
// @Description Delete an assignment by ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Success 200 {string} string "Assignment deleted successfully"
// @Router /assignments/{assignmentId} [delete]
func (c *AssignmentsController) DeleteAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting assignment")
        id := ctx.Param("assignmentId")

        if err := c.service.DeleteAssignment(id); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error deleting assignment", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignment deleted")
        ctx.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "log/slog"
        "net/http"
        "slices"

        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"

        "github.com/gin-gonic/gin"
)

type CourseController struct {
        service service.CourseServiceInterface
}

func NewCourseController(service service.CourseServiceInterface) *CourseController <span class="cov8" title="1">{
        return &amp;CourseController{service: service}
}</span>

// @Summary Get all courses
// @Description Get all courses available in the database
// @Tags courses
// @Accept json
// @Produce json
// @Success 200 {array} model.Course
// @Router /courses [get]
func (c *CourseController) GetCourses(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting courses")

        courses, err := c.service.GetCourses()
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting courses", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Course creation
// @Description Create a new course
// @Tags courses
// @Accept json
// @Produce json
// @Param course body schemas.CreateCourseRequest true "Course to create"
// @Success 201 {object} model.Course
// @Router /courses [post]
func (c *CourseController) CreateCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating course")

        var course schemas.CreateCourseRequest
        if err := ctx.ShouldBindJSON(&amp;course); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">createdCourse, err := c.service.CreateCourse(course)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course created", "course", createdCourse)
        ctx.JSON(http.StatusCreated, createdCourse)</span>
}

// @Summary Get a course by ID
// @Description Get a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {object} model.Course
// @Router /courses/{id} [get]
func (c *CourseController) GetCourseById(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course by ID")

        id := ctx.Param("id")
        course, err := c.service.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course by ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course retrieved", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Delete a course
// @Description Delete a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {object} schemas.DeleteCourseResponse
// @Router /courses/{id} [delete]
func (c *CourseController) DeleteCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting course")
        id := ctx.Param("id")

        err := c.service.DeleteCourse(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error deleting course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course deleted", "id", id)
        ctx.JSON(http.StatusOK, gin.H{"message": "Course deleted successfully"})</span>
}

// @Summary Get a course by teacher ID
// @Description Get a course by teacher ID
// @Tags courses
// @Accept json
// @Produce json
// @Param teacherId path string true "Teacher ID"
// @Success 200 {array} model.Course
// @Router /courses/teacher/{teacherId} [get]
func (c *CourseController) GetCourseByTeacherId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course by teacher ID")
        teacherId := ctx.Param("teacherId")
        course, err := c.service.GetCourseByTeacherId(teacherId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course by teacher ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course retrieved", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Get a course by title
// @Description Get a course by title
// @Tags courses
// @Accept json
// @Produce json
// @Param title path string true "Course title"
// @Success 200 {array} model.Course
// @Router /courses/title/{title} [get]
func (c *CourseController) GetCourseByTitle(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course by title")
        title := ctx.Param("title")
        course, err := c.service.GetCourseByTitle(title)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course by title", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course retrieved", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Update a course
// @Description Update a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param course body schemas.UpdateCourseRequest true "Course to update"
// @Success 200 {object} model.Course
// @Router /courses/{id} [put]
func (c *CourseController) UpdateCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating course")
        id := ctx.Param("id")

        var updateCourseRequest schemas.UpdateCourseRequest
        if err := ctx.ShouldBindJSON(&amp;updateCourseRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">updatedCourse, err := c.service.UpdateCourse(id, updateCourseRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course updated", "course", updatedCourse)
        ctx.JSON(http.StatusOK, updatedCourse)</span>
}

// @Summary Get courses by student ID
// @Description Get courses by student ID
// @Tags courses
// @Accept json
// @Produce json
// @Param studentId path string true "Student ID"
// @Success 200 {array} model.Course
// @Router /courses/student/{studentId} [get]
func (c *CourseController) GetCoursesByStudentId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting courses by student ID")
        studentId := ctx.Param("studentId")
        courses, err := c.service.GetCoursesByStudentId(studentId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting courses by student ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Get courses by user ID
// @Description Get courses by user ID
// @Tags courses
// @Accept json
// @Produce json
// @Param userId path string true "User ID"
// @Success 200 {array} model.Course
// @Router /courses/user/{userId} [get]
func (c *CourseController) GetCoursesByUserId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting courses by user ID")
        userId := ctx.Param("userId")
        courses, err := c.service.GetCoursesByUserId(userId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting courses by user ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Add an aux teacher to a course
// @Description Add an aux teacher to a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
func (c *CourseController) AddAuxTeacherToCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Adding aux teacher to course")
        id := ctx.Param("id")
        if id == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var auxTeacherRequest schemas.AddAuxTeacherToCourseRequest
        if err := ctx.ShouldBindJSON(&amp;auxTeacherRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">teacherId := auxTeacherRequest.TeacherID
        auxTeacherId := auxTeacherRequest.AuxTeacherID
        course, err := c.service.AddAuxTeacherToCourse(id, teacherId, auxTeacherId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error adding aux teacher to course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Aux teacher added to course", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Remove an aux teacher from a course
// @Description Remove an aux teacher from a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param removeAuxTeacherRequest body schemas.RemoveAuxTeacherFromCourseRequest true "Remove aux teacher from course request"
// @Success 200 {object} model.Course
// @Router /courses/{id}/remove-aux-teacher [delete]
func (c *CourseController) RemoveAuxTeacherFromCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Removing aux teacher from course")
        id := ctx.Param("id")
        if id == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var removeAuxTeacherRequest schemas.RemoveAuxTeacherFromCourseRequest
        if err := ctx.ShouldBindJSON(&amp;removeAuxTeacherRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">teacherId := removeAuxTeacherRequest.TeacherID
        auxTeacherId := removeAuxTeacherRequest.AuxTeacherID
        course, err := c.service.RemoveAuxTeacherFromCourse(id, teacherId, auxTeacherId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error removing aux teacher from course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Aux teacher removed from course", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Get favourite courses
// @Description Get favourite courses by student ID
// @Tags courses
// @Accept json
// @Produce json
// @Param studentId path string true "Student ID"
// @Success 200 {array} model.Course
// @Router /courses/favourite/{studentId} [get]
func (c *CourseController) GetFavouriteCourses(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting favourite courses")
        studentId := ctx.Param("studentId")
        if studentId == "" </span><span class="cov8" title="1">{
                slog.Error("Student ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Student ID is required"})
                return
        }</span>

        <span class="cov8" title="1">courses, err := c.service.GetFavouriteCourses(studentId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting favourite courses", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Favourite courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Create course feedback
// @Description Create course feedback by course ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param feedback body schemas.CreateCourseFeedbackRequest true "Course feedback"
// @Success 200 {object} model.CourseFeedback
// @Router /courses/{id}/feedback [post]
func (c *CourseController) CreateCourseFeedback(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating course feedback")
        courseId := ctx.Param("id")
        if courseId == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var feedback schemas.CreateCourseFeedbackRequest
        if err := ctx.ShouldBindJSON(&amp;feedback); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding create course feedback request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if !slices.Contains(model.FeedbackTypes, feedback.FeedbackType) </span><span class="cov8" title="1">{
                slog.Error("Invalid feedback type")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid feedback type"})
                return
        }</span>

        <span class="cov8" title="1">feedbackModel, err := c.service.CreateCourseFeedback(courseId, feedback)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating course feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Course feedback created", "feedback", feedbackModel)
        ctx.JSON(http.StatusOK, feedbackModel)</span>
}

func (c *CourseController) GetCourseFeedback(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course feedback")
        courseId := ctx.Param("id")
        if courseId == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var getCourseFeedbackRequest schemas.GetCourseFeedbackRequest
        if err := ctx.ShouldBindJSON(&amp;getCourseFeedbackRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding get course feedback request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">feedback, err := c.service.GetCourseFeedback(courseId, getCourseFeedbackRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Course feedback retrieved", "feedback", feedback)
        ctx.JSON(http.StatusOK, feedback)</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"
        "log/slog"
        "net/http"
        "slices"

        "github.com/gin-gonic/gin"
)

type EnrollmentController struct {
        enrollmentService service.EnrollmentServiceInterface
}

func NewEnrollmentController(enrollmentService service.EnrollmentServiceInterface) *EnrollmentController <span class="cov8" title="1">{
        return &amp;EnrollmentController{enrollmentService: enrollmentService}
}</span>

// @Summary Enroll a student in a course
// @Description Enroll a student in a course
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param enrollmentRequest body schemas.EnrollStudentRequest true "Enrollment request"
// @Router /courses/{id}/enroll [post]
func (c *EnrollmentController) EnrollStudent(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Enrolling student", "studentId", ctx.Param("studentId"), "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID", "courseId", courseID)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var enrollmentRequest schemas.EnrollStudentRequest
        if err := ctx.ShouldBindJSON(&amp;enrollmentRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding enrollment request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.EnrollStudent(enrollmentRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error enrolling student", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Student enrolled in course", "studentId", enrollmentRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusCreated, gin.H{"message": "Student successfully enrolled in course"})</span>
}

// @Summary Unenroll a student from a course
// @Description Unenroll a student from a course
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param unenrollmentRequest body schemas.UnenrollStudentRequest true "Unenrollment request"
// @Success 200 {object} schemas.UnenrollStudentResponse
// @Router /courses/{id}/unenroll [delete]
func (c *EnrollmentController) UnenrollStudent(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Unenrolling student", "studentId", ctx.Param("studentId"), "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid student ID or course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid student ID or course ID"})
                return
        }</span>

        <span class="cov8" title="1">var unenrollmentRequest schemas.UnenrollStudentRequest
        if err := ctx.ShouldBindJSON(&amp;unenrollmentRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding unenrollment request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.UnenrollStudent(unenrollmentRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error unenrolling student", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Student unenrolled from course", "studentId", unenrollmentRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Student successfully unenrolled from course"})</span>
}

// @Summary Get enrollments by course ID
// @Description Get enrollments by course ID
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {array} model.Enrollment
// @Router /courses/{id}/enrollments [get]
func (c *EnrollmentController) GetEnrollmentsByCourseId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting enrollments by course ID", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        enrollments, err := c.enrollmentService.GetEnrollmentsByCourseId(courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting enrollments by course ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, enrollments)</span>
}

// @Summary Set a course as favourite
// @Description Set a course as favourite
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param favouriteCourseRequest body schemas.SetFavouriteCourseRequest true "Favourite course request"
// @Success 200 {object} schemas.SetFavouriteCourseResponse
// @Router /courses/{id}/favourite [post]
func (c *EnrollmentController) SetFavouriteCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Setting favourite course", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var favouriteCourseRequest schemas.SetFavouriteCourseRequest
        if err := ctx.ShouldBindJSON(&amp;favouriteCourseRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding favourite course request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.SetFavouriteCourse(favouriteCourseRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error setting favourite course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Favourite course set", "studentId", favouriteCourseRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Favourite course set"})</span>
}

// @Summary Unset a course as favourite
// @Description Unset a course as favourite
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param unsetFavouriteCourseRequest body schemas.UnsetFavouriteCourseRequest true "Unset favourite course request"
// @Success 200 {object} schemas.UnsetFavouriteCourseResponse
// @Router /courses/{id}/favourite [delete]
func (c *EnrollmentController) UnsetFavouriteCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Unsetting favourite course", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var unsetFavouriteCourseRequest schemas.UnsetFavouriteCourseRequest
        if err := ctx.ShouldBindJSON(&amp;unsetFavouriteCourseRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding unset favourite course request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.UnsetFavouriteCourse(unsetFavouriteCourseRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error unsetting favourite course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Favourite course unset", "studentId", unsetFavouriteCourseRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Favourite course unset"})</span>
}

// @Summary Create a feedback for a course
// @Description Create a feedback for a course
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param feedbackRequest body schemas.CreateStudentFeedbackRequest true "Feedback request"
// @Success 200 {object} schemas.CreateStudentFeedbackResponse
// @Router /courses/{id}/student-feedback [post]
func (c *EnrollmentController) CreateFeedback(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating feedback", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var feedbackRequest schemas.CreateStudentFeedbackRequest
        if err := ctx.ShouldBindJSON(&amp;feedbackRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding feedback request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if !slices.Contains(model.FeedbackTypes, feedbackRequest.FeedbackType) </span><span class="cov8" title="1">{
                slog.Error("Invalid feedback type")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid feedback type"})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.CreateStudentFeedback(feedbackRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Feedback created", "studentId", feedbackRequest.StudentUUID, "teacherId", feedbackRequest.TeacherUUID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Feedback created"})</span>
}

// @Summary Get feedback by student ID
// @Description Get feedback by student ID
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Student ID"
// @Param getFeedbackByStudentIdRequest body schemas.GetFeedbackByStudentIdRequest true "Get feedback by student ID request"
// @Success 200 {array} model.StudentFeedback
// @Router /feedback/student/{id} [get]
func (c *EnrollmentController) GetFeedbackByStudentId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting feedback by student ID", "studentId", ctx.Param("id"))
        studentID := ctx.Param("id")

        if studentID == "" </span><span class="cov0" title="0">{
                slog.Error("Invalid student ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid student ID"})
                return
        }</span>

        <span class="cov8" title="1">var getFeedbackByStudentIdRequest schemas.GetFeedbackByStudentIdRequest
        if err := ctx.ShouldBindJSON(&amp;getFeedbackByStudentIdRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding get feedback by student ID request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">feedback, err := c.enrollmentService.GetFeedbackByStudentId(studentID, getFeedbackByStudentIdRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting feedback by student ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Feedback retrieved", "studentId", studentID)
        ctx.JSON(http.StatusOK, feedback)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"
        "log"
        "log/slog"
        "net/http"

        "github.com/gin-gonic/gin"
)

type ModuleController struct {
        service service.ModuleServiceInterface
}

func NewModuleController(service service.ModuleServiceInterface) *ModuleController <span class="cov8" title="1">{
        return &amp;ModuleController{
                service: service,
        }
}</span>

// @Summary Module creation
// @Description Create a new module
// @Tags modules
// @Accept json
// @Produce json
// @Param module body schemas.CreateModuleRequest true "Module to create"
// @Success 201 {object} model.Module
// @Router /modules [post]
func (c *ModuleController) CreateModule(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating module")

        var module schemas.CreateModuleRequest
        if err := ctx.ShouldBindJSON(&amp;module); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">log.Printf("module: %v\n", module)

        createdModule, err := c.service.CreateModule(module)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating module", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module created", "module", createdModule)
        ctx.JSON(http.StatusCreated, createdModule)</span>
}

// @Summary Get modules by course ID
// @Description Get modules by course ID
// @Tags modules
// @Accept json
// @Produce json
// @Param courseId path string true "Course ID"
// @Success 200 {array} model.Module
// @Router /modules/course/{courseId} [get]
func (c *ModuleController) GetModulesByCourseId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting modules by course ID")
        courseId := ctx.Param("courseId")

        modules, err := c.service.GetModulesByCourseId(courseId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting modules by course ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Modules retrieved", "modules", modules)
        ctx.JSON(http.StatusOK, modules)</span>
}

// @Summary Get a module by ID
// @Description Get a module by ID
// @Tags modules
// @Accept json
// @Produce json
// @Param id path string true "Module ID"
// @Success 200 {object} model.Module
// @Router /modules/{id} [get]
func (c *ModuleController) GetModuleById(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting module by ID")
        id := ctx.Param("id")

        module, err := c.service.GetModuleById(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting module by ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module retrieved", "module", module)
        ctx.JSON(http.StatusOK, module)</span>
}

// @Summary Update a module
// @Description Update a module by ID
// @Tags modules
// @Accept json
// @Produce json
// @Param id path string true "Module ID"
// @Param module body schemas.UpdateModuleRequest true "Module to update"
// @Success 200 {object} model.Module
// @Router /modules/{id} [put]
func (c *ModuleController) UpdateModule(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating module")
        id := ctx.Param("id")

        var module model.Module
        if err := ctx.ShouldBindJSON(&amp;module); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">updatedModule, err := c.service.UpdateModule(id, module)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating module", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module updated", "module", updatedModule)
        ctx.JSON(http.StatusOK, updatedModule)</span>
}

// @Summary Delete a module
// @Description Delete a module by ID
// @Tags modules
// @Accept json
// @Produce json
// @Param id path string true "Module ID"
// @Success 204 {string} string "Module deleted successfully"
// @Router /modules/{id} [delete]
func (c *ModuleController) DeleteModule(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting module")
        id := ctx.Param("id")

        err := c.service.DeleteModule(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error deleting module", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module deleted", "id", id)
        ctx.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"

        "github.com/gin-gonic/gin"
)

type SubmissionController struct {
        submissionService service.SubmissionServiceInterface
}

func NewSubmissionController(submissionService service.SubmissionServiceInterface) *SubmissionController <span class="cov8" title="1">{
        return &amp;SubmissionController{
                submissionService: submissionService,
        }
}</span>

type CreateSubmissionRequest struct {
        Answers []model.Answer `json:"answers"`
}

// @Summary Create a submission
// @Description Create a submission
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param submission body CreateSubmissionRequest true "Submission to create"
// @Success 201 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions [post]
func (c *SubmissionController) CreateSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        var req CreateSubmissionRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Get student info from context (assuming middleware sets this)
        <span class="cov8" title="1">studentUUID := ctx.GetString("student_uuid")
        studentName := ctx.GetString("student_name")

        submission, err := c.submissionService.GetOrCreateSubmission(ctx, assignmentID, studentUUID, studentName)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">submission.Answers = req.Answers
        submission.UpdatedAt = time.Now()

        if err := c.submissionService.UpdateSubmission(ctx, submission); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Get a submission by ID
// @Description Get a submission by ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id} [get]
func (c *SubmissionController) GetSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        submission, err := c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        // Validate submission belongs to the assignment
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Update a submission
// @Description Update a submission by ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Param submission body model.Submission true "Submission to update"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id} [put]
func (c *SubmissionController) UpdateSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        var submission model.Submission
        if err := ctx.ShouldBindJSON(&amp;submission); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate submission ID matches URL
        <span class="cov8" title="1">if submission.ID.Hex() != id </span><span class="cov8" title="1">{
                fmt.Printf("submission ID mismatch: %s != %s\n", submission.ID.Hex(), id)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "submission ID mismatch"})
                return
        }</span>

        // Validate submission belongs to the assignment
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "assignment ID mismatch"})
                return
        }</span>

        // Validate student ownership
        <span class="cov8" title="1">studentUUID := ctx.GetString("student_uuid")
        if submission.StudentUUID != studentUUID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">if err := c.submissionService.UpdateSubmission(ctx, &amp;submission); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Submit a submission
// @Description Submit a submission by ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id}/submit [post]
func (c *SubmissionController) SubmitSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        // Validate submission belongs to the assignment
        submission, err := c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        <span class="cov8" title="1">if err := c.submissionService.SubmitSubmission(ctx, id); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">submission, err = c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Get submissions by assignment ID
// @Description Get submissions by assignment ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Success 200 {array} model.Submission
// @Router /assignments/{assignmentId}/submissions [get]
func (c *SubmissionController) GetSubmissionsByAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")

        submissions, err := c.submissionService.GetSubmissionsByAssignment(ctx, assignmentID)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submissions)</span>
}

// @Summary Get submissions by student ID
// @Description Get submissions by student ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param studentUUID path string true "Student ID"
// @Success 200 {array} model.Submission
// @Router /students/{studentUUID}/submissions [get]
func (c *SubmissionController) GetSubmissionsByStudent(ctx *gin.Context) <span class="cov8" title="1">{
        studentUUID := ctx.Param("studentUUID")

        // Validate student access
        requestingStudentUUID := ctx.GetString("student_uuid")
        if studentUUID != requestingStudentUUID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">submissions, err := c.submissionService.GetSubmissionsByStudent(ctx, studentUUID)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submissions)</span>
}

// @Summary Grade a submission
// @Description Grade a submission by ID (for teachers)
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Param gradeRequest body schemas.GradeSubmissionRequest true "Grade request"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id}/grade [put]
func (c *SubmissionController) GradeSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        var gradeRequest schemas.GradeSubmissionRequest
        if err := ctx.ShouldBindJSON(&amp;gradeRequest); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Get teacher info from context
        <span class="cov8" title="1">teacherUUID := ctx.GetString("teacher_uuid")

        // Validate teacher permissions for this assignment
        if err := c.submissionService.ValidateTeacherPermissions(ctx, assignmentID, teacherUUID); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusForbidden, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate submission belongs to the assignment
        <span class="cov8" title="1">submission, err := c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        // Grade the submission
        <span class="cov8" title="1">gradedSubmission, err := c.submissionService.GradeSubmission(ctx, id, gradeRequest.Score, gradeRequest.Feedback)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gradedSubmission)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "courses-service/src/config"
        "log/slog"

        "context"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

func NewMongoDBClient(config *config.Config) (*mongo.Client, error) <span class="cov8" title="1">{
        clientOptions := options.Client().ApplyURI(config.DBURI).SetAuth(options.Credential{
                Username: config.DBUsername,
                Password: config.DBPassword,
        })

        client, err := mongo.Connect(context.Background(), clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to connect to database", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">slog.Info("Connected to database")

        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "El mejor grupo de todos ndea deau",
            "url": "https://github.com/classconnect-grupo3",
            "email": "classconnectingsoft2@gmail.com"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/assignments": {
            "get": {
                "description": "Get all assignments",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "assignments"
                ],
                "summary": "Get all assignments",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Assignment"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Create an assignment",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "assignments"
                ],
                "summary": "Create an assignment",
                "parameters": [
                    {
                        "description": "Assignment to create",
                        "name": "assignment",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.CreateAssignmentRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/model.Assignment"
                        }
                    }
                }
            }
        },
        "/assignments/course/{courseId}": {
            "get": {
                "description": "Get assignments by course ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "assignments"
                ],
                "summary": "Get assignments by course ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "courseId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Assignment"
                            }
                        }
                    }
                }
            }
        },
        "/assignments/{assignmentId}": {
            "get": {
                "description": "Get an assignment by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "assignments"
                ],
                "summary": "Get an assignment by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Assignment"
                        }
                    }
                }
            },
            "put": {
                "description": "Update an assignment by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "assignments"
                ],
                "summary": "Update an assignment",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Assignment to update",
                        "name": "assignment",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.UpdateAssignmentRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Assignment"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete an assignment by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "assignments"
                ],
                "summary": "Delete an assignment",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Assignment deleted successfully",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/assignments/{assignmentId}/submissions": {
            "get": {
                "description": "Get submissions by assignment ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "submissions"
                ],
                "summary": "Get submissions by assignment ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Submission"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Create a submission",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "submissions"
                ],
                "summary": "Create a submission",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Submission to create",
                        "name": "submission",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controller.CreateSubmissionRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/model.Submission"
                        }
                    }
                }
            }
        },
        "/assignments/{assignmentId}/submissions/{id}": {
            "get": {
                "description": "Get a submission by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "submissions"
                ],
                "summary": "Get a submission by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Submission ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Submission"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a submission by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "submissions"
                ],
                "summary": "Update a submission",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Submission ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Submission to update",
                        "name": "submission",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/model.Submission"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Submission"
                        }
                    }
                }
            }
        },
        "/assignments/{assignmentId}/submissions/{id}/grade": {
            "put": {
                "description": "Grade a submission by ID (for teachers)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "submissions"
                ],
                "summary": "Grade a submission",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Submission ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Grade request",
                        "name": "gradeRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.GradeSubmissionRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Submission"
                        }
                    }
                }
            }
        },
        "/assignments/{assignmentId}/submissions/{id}/submit": {
            "post": {
                "description": "Submit a submission by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "submissions"
                ],
                "summary": "Submit a submission",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Assignment ID",
                        "name": "assignmentId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Submission ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Submission"
                        }
                    }
                }
            }
        },
        "/courses": {
            "get": {
                "description": "Get all courses available in the database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Get all courses",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Course"
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new course",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Course creation",
                "parameters": [
                    {
                        "description": "Course to create",
                        "name": "course",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.CreateCourseRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/model.Course"
                        }
                    }
                }
            }
        },
        "/courses/favourite/{studentId}": {
            "get": {
                "description": "Get favourite courses by student ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Get favourite courses",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Student ID",
                        "name": "studentId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Course"
                            }
                        }
                    }
                }
            }
        },
        "/courses/student/{studentId}": {
            "get": {
                "description": "Get courses by student ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Get courses by student ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Student ID",
                        "name": "studentId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Course"
                            }
                        }
                    }
                }
            }
        },
        "/courses/teacher/{teacherId}": {
            "get": {
                "description": "Get a course by teacher ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Get a course by teacher ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Teacher ID",
                        "name": "teacherId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Course"
                            }
                        }
                    }
                }
            }
        },
        "/courses/title/{title}": {
            "get": {
                "description": "Get a course by title",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Get a course by title",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course title",
                        "name": "title",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Course"
                            }
                        }
                    }
                }
            }
        },
        "/courses/user/{userId}": {
            "get": {
                "description": "Get courses by user ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Get courses by user ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "userId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Course"
                            }
                        }
                    }
                }
            }
        },
        "/courses/{id}": {
            "get": {
                "description": "Get a course by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Get a course by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Course"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a course by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Update a course",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Course to update",
                        "name": "course",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.UpdateCourseRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Course"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a course by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Delete a course",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/schemas.DeleteCourseResponse"
                        }
                    }
                }
            }
        },
        "/courses/{id}/enroll": {
            "post": {
                "description": "Enroll a student in a course",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollments"
                ],
                "summary": "Enroll a student in a course",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Enrollment request",
                        "name": "enrollmentRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.EnrollStudentRequest"
                        }
                    }
                ],
                "responses": {}
            }
        },
        "/courses/{id}/enrollments": {
            "get": {
                "description": "Get enrollments by course ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollments"
                ],
                "summary": "Get enrollments by course ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Enrollment"
                            }
                        }
                    }
                }
            }
        },
        "/courses/{id}/favourite": {
            "post": {
                "description": "Set a course as favourite",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollments"
                ],
                "summary": "Set a course as favourite",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Favourite course request",
                        "name": "favouriteCourseRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.SetFavouriteCourseRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/schemas.SetFavouriteCourseResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Unset a course as favourite",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollments"
                ],
                "summary": "Unset a course as favourite",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Unset favourite course request",
                        "name": "unsetFavouriteCourseRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.UnsetFavouriteCourseRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/schemas.UnsetFavouriteCourseResponse"
                        }
                    }
                }
            }
        },
        "/courses/{id}/remove-aux-teacher": {
            "delete": {
                "description": "Remove an aux teacher from a course by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "courses"
                ],
                "summary": "Remove an aux teacher from a course",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Remove aux teacher from course request",
                        "name": "removeAuxTeacherRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.RemoveAuxTeacherFromCourseRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Course"
                        }
                    }
                }
            }
        },
        "/courses/{id}/unenroll": {
            "delete": {
                "description": "Unenroll a student from a course",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "enrollments"
                ],
                "summary": "Unenroll a student from a course",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Unenrollment request",
                        "name": "unenrollmentRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.UnenrollStudentRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/schemas.UnenrollStudentResponse"
                        }
                    }
                }
            }
        },
        "/modules": {
            "post": {
                "description": "Create a new module",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "modules"
                ],
                "summary": "Module creation",
                "parameters": [
                    {
                        "description": "Module to create",
                        "name": "module",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.CreateModuleRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/model.Module"
                        }
                    }
                }
            }
        },
        "/modules/course/{courseId}": {
            "get": {
                "description": "Get modules by course ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "modules"
                ],
                "summary": "Get modules by course ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Course ID",
                        "name": "courseId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Module"
                            }
                        }
                    }
                }
            }
        },
        "/modules/{id}": {
            "get": {
                "description": "Get a module by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "modules"
                ],
                "summary": "Get a module by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Module ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Module"
                        }
                    }
                }
            },
            "put": {
                "description": "Update a module by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "modules"
                ],
                "summary": "Update a module",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Module ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Module to update",
                        "name": "module",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schemas.UpdateModuleRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/model.Module"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a module by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "modules"
                ],
                "summary": "Delete a module",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Module ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Module deleted successfully",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/students/{studentUUID}/submissions": {
            "get": {
                "description": "Get submissions by student ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "submissions"
                ],
                "summary": "Get submissions by student ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Student ID",
                        "name": "studentUUID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/model.Submission"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "controller.CreateSubmissionRequest": {
            "type": "object",
            "properties": {
                "answers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Answer"
                    }
                }
            }
        },
        "model.Answer": {
            "type": "object",
            "properties": {
                "content": {
                    "description": "Can be string, []string for multiple choice, or file URL"
                },
                "question_id": {
                    "type": "string"
                },
                "type": {
                    "description": "text, multiple_choice, file",
                    "type": "string"
                }
            }
        },
        "model.Assignment": {
            "type": "object",
            "properties": {
                "course_id": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "due_date": {
                    "type": "string"
                },
                "grace_period": {
                    "description": "Minutes of tolerance after due_date",
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "instructions": {
                    "type": "string"
                },
                "passing_score": {
                    "description": "Minimum score to pass",
                    "type": "number"
                },
                "questions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Question"
                    }
                },
                "status": {
                    "description": "draft, published",
                    "type": "string"
                },
                "submission_rules": {
                    "description": "Array of rules for submission",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "total_points": {
                    "type": "number"
                },
                "type": {
                    "description": "exam, homework, quiz",
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "model.Course": {
            "type": "object",
            "properties": {
                "aux_teachers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "capacity": {
                    "type": "integer"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "modules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Module"
                    }
                },
                "start_date": {
                    "type": "string"
                },
                "students_amount": {
                    "type": "integer"
                },
                "teacher_name": {
                    "type": "string"
                },
                "teacher_uuid": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "model.Enrollment": {
            "type": "object",
            "properties": {
                "completed_date": {
                    "type": "string"
                },
                "course_id": {
                    "type": "string"
                },
                "enrolled_at": {
                    "type": "string"
                },
                "favourite": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/model.EnrollmentStatus"
                },
                "student_id": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "model.EnrollmentStatus": {
            "type": "string",
            "enum": [
                "active",
                "dropped",
                "completed"
            ],
            "x-enum-varnames": [
                "EnrollmentStatusActive",
                "EnrollmentStatusDropped",
                "EnrollmentStatusCompleted"
            ]
        },
        "model.Module": {
            "type": "object",
            "properties": {
                "content": {
                    "description": "TODO change this with media in the future",
                    "type": "string"
                },
                "course_id": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "model.Question": {
            "type": "object",
            "properties": {
                "correct_answers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "id": {
                    "type": "string"
                },
                "options": {
                    "description": "For multiple choice",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "order": {
                    "type": "integer"
                },
                "points": {
                    "type": "number"
                },
                "text": {
                    "type": "string"
                },
                "type": {
                    "$ref": "#/definitions/model.QuestionType"
                }
            }
        },
        "model.QuestionType": {
            "type": "string",
            "enum": [
                "text",
                "multiple_choice",
                "file"
            ],
            "x-enum-varnames": [
                "QuestionTypeText",
                "QuestionTypeMultipleChoice",
                "QuestionTypeFile"
            ]
        },
        "model.Submission": {
            "type": "object",
            "properties": {
                "answers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Answer"
                    }
                },
                "assignment_id": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "feedback": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "score": {
                    "type": "number"
                },
                "status": {
                    "$ref": "#/definitions/model.SubmissionStatus"
                },
                "student_name": {
                    "type": "string"
                },
                "student_uuid": {
                    "type": "string"
                },
                "submitted_at": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "model.SubmissionStatus": {
            "type": "string",
            "enum": [
                "draft",
                "submitted",
                "late"
            ],
            "x-enum-varnames": [
                "SubmissionStatusDraft",
                "SubmissionStatusSubmitted",
                "SubmissionStatusLate"
            ]
        },
        "schemas.CreateAssignmentRequest": {
            "type": "object",
            "required": [
                "course_id",
                "description",
                "due_date",
                "grace_period",
                "instructions",
                "passing_score",
                "questions",
                "status",
                "title",
                "total_points",
                "type"
            ],
            "properties": {
                "course_id": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "due_date": {
                    "type": "string"
                },
                "grace_period": {
                    "type": "integer"
                },
                "instructions": {
                    "type": "string"
                },
                "passing_score": {
                    "type": "number"
                },
                "questions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Question"
                    }
                },
                "status": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "total_points": {
                    "type": "number"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "schemas.CreateCourseRequest": {
            "type": "object",
            "required": [
                "capacity",
                "description",
                "end_date",
                "start_date",
                "teacher_id",
                "title"
            ],
            "properties": {
                "capacity": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "start_date": {
                    "type": "string"
                },
                "teacher_id": {
                    "type": "string"
                },
                "teacher_name": {
                    "description": "TODO: this will later be consulted with users service to get the teacher name",
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "schemas.CreateModuleRequest": {
            "type": "object",
            "required": [
                "course_id",
                "description",
                "title"
            ],
            "properties": {
                "content": {
                    "type": "string"
                },
                "course_id": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "schemas.DeleteCourseResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "schemas.EnrollStudentRequest": {
            "type": "object",
            "required": [
                "student_id"
            ],
            "properties": {
                "student_id": {
                    "type": "string"
                }
            }
        },
        "schemas.GradeSubmissionRequest": {
            "type": "object",
            "properties": {
                "feedback": {
                    "type": "string"
                },
                "score": {
                    "type": "number"
                }
            }
        },
        "schemas.RemoveAuxTeacherFromCourseRequest": {
            "type": "object",
            "required": [
                "aux_teacher_id",
                "teacher_id"
            ],
            "properties": {
                "aux_teacher_id": {
                    "type": "string"
                },
                "teacher_id": {
                    "type": "string"
                }
            }
        },
        "schemas.SetFavouriteCourseRequest": {
            "type": "object",
            "required": [
                "student_id"
            ],
            "properties": {
                "student_id": {
                    "type": "string"
                }
            }
        },
        "schemas.SetFavouriteCourseResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "schemas.UnenrollStudentRequest": {
            "type": "object",
            "required": [
                "student_id"
            ],
            "properties": {
                "student_id": {
                    "type": "string"
                }
            }
        },
        "schemas.UnenrollStudentResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "schemas.UnsetFavouriteCourseRequest": {
            "type": "object",
            "required": [
                "student_id"
            ],
            "properties": {
                "student_id": {
                    "type": "string"
                }
            }
        },
        "schemas.UnsetFavouriteCourseResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "schemas.UpdateAssignmentRequest": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "due_date": {
                    "type": "string"
                },
                "grace_period": {
                    "type": "integer"
                },
                "instructions": {
                    "type": "string"
                },
                "passing_score": {
                    "type": "number"
                },
                "questions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/model.Question"
                    }
                },
                "status": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "total_points": {
                    "type": "number"
                },
                "type": {
                    "type": "string"
                }
            }
        },
        "schemas.UpdateCourseRequest": {
            "type": "object",
            "properties": {
                "capacity": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "start_date": {
                    "type": "string"
                },
                "teacher_id": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "schemas.UpdateModuleRequest": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Courses Service API",
        Description:      "API for managing courses and related resources",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "courses-service/src/config"
        "courses-service/src/router"
        "fmt"
        "log"

        _ "courses-service/src/docs"

        _ "github.com/swaggo/files"
        _ "github.com/swaggo/gin-swagger"
)

// @title Courses Service API
// @version 1.0
// @description API for managing courses and related resources

// @contact.name   El mejor grupo de todos ndea deau
// @contact.url    https://github.com/classconnect-grupo3
// @contact.email  classconnectingsoft2@gmail.com

func main() <span class="cov0" title="0">{
        config := config.NewConfig()
        r := router.NewRouter(config)
        if err := r.Run(fmt.Sprintf("%s:%s", config.Host, config.Port)); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

// StudentAuth is a middleware that extracts student information from the X-Student-UUID and X-Student-Name
// headers and sets them in the context for handlers to use.
func StudentAuth() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                studentUUID := c.GetHeader("X-Student-UUID")
                studentName := c.GetHeader("X-Student-Name")

                if studentUUID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "X-Student-UUID header is required"})
                        c.Abort()
                        return
                }</span>

                // Set values in context for downstream handlers
                <span class="cov0" title="0">c.Set("student_uuid", studentUUID)
                c.Set("student_name", studentName)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

// TeacherAuth is a middleware that extracts teacher information from the X-Teacher-UUID and X-Teacher-Name
// headers and sets them in the context for handlers to use.
func TeacherAuth() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                teacherUUID := c.GetHeader("X-Teacher-UUID")
                teacherName := c.GetHeader("X-Teacher-Name")

                if teacherUUID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "X-Teacher-UUID header is required"})
                        c.Abort()
                        return
                }</span>

                // Set values in context for downstream handlers
                <span class="cov0" title="0">c.Set("teacher_uuid", teacherUUID)
                c.Set("teacher_name", teacherName)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type AssignmentRepository struct {
        db                   *mongo.Client
        dbName               string
        assignmentCollection *mongo.Collection
}

func NewAssignmentRepository(db *mongo.Client, dbName string) AssignmentRepositoryInterface <span class="cov8" title="1">{
        return &amp;AssignmentRepository{
                db:                   db,
                dbName:               dbName,
                assignmentCollection: db.Database(dbName).Collection("assignments"),
        }
}</span>

func (r *AssignmentRepository) CreateAssignment(assignment model.Assignment) (*model.Assignment, error) <span class="cov8" title="1">{
        result, err := r.assignmentCollection.InsertOne(context.TODO(), assignment)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create assignment: %v", err)
        }</span>

        <span class="cov8" title="1">assignment.ID = result.InsertedID.(primitive.ObjectID)
        return &amp;assignment, nil</span>
}

func (r *AssignmentRepository) GetAssignments() ([]*model.Assignment, error) <span class="cov8" title="1">{
        cursor, err := r.assignmentCollection.Find(context.TODO(), bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments: %v", err)
        }</span>

        <span class="cov8" title="1">var assignments []*model.Assignment
        if err := cursor.All(context.TODO(), &amp;assignments); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments: %v", err)
        }</span>

        // Ensure we return an empty slice instead of nil when no documents are found
        <span class="cov8" title="1">if assignments == nil </span><span class="cov8" title="1">{
                assignments = []*model.Assignment{}
        }</span>

        <span class="cov8" title="1">return assignments, nil</span>
}

func (r *AssignmentRepository) GetByID(ctx context.Context, id string) (*model.Assignment, error) <span class="cov8" title="1">{
        var assignment model.Assignment
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get assignment by id: %v", err)
        }</span>

        <span class="cov8" title="1">err = r.assignmentCollection.FindOne(ctx, bson.M{"_id": objectId}).Decode(&amp;assignment)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get assignment by id: %v", err)</span>
        }

        <span class="cov8" title="1">return &amp;assignment, nil</span>
}

func (r *AssignmentRepository) GetAssignmentsByCourseId(courseId string) ([]*model.Assignment, error) <span class="cov8" title="1">{
        cursor, err := r.assignmentCollection.Find(context.TODO(), bson.M{"course_id": courseId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments by course id: %v", err)
        }</span>

        <span class="cov8" title="1">var assignments []*model.Assignment
        if err := cursor.All(context.TODO(), &amp;assignments); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments by course id: %v", err)
        }</span>

        // Ensure we return an empty slice instead of nil when no documents are found
        <span class="cov8" title="1">if assignments == nil </span><span class="cov8" title="1">{
                assignments = []*model.Assignment{}
        }</span>

        <span class="cov8" title="1">return assignments, nil</span>
}

func filterEmptyAssignmentFields(assignment model.Assignment) bson.M <span class="cov8" title="1">{
        update := bson.M{}

        if assignment.Title != "" </span><span class="cov8" title="1">{
                update["title"] = assignment.Title
        }</span>
        <span class="cov8" title="1">if assignment.Description != "" </span><span class="cov8" title="1">{
                update["description"] = assignment.Description
        }</span>
        <span class="cov8" title="1">if assignment.Type != "" </span><span class="cov8" title="1">{
                update["type"] = assignment.Type
        }</span>
        <span class="cov8" title="1">if !assignment.DueDate.IsZero() </span><span class="cov0" title="0">{
                update["due_date"] = assignment.DueDate
        }</span>
        <span class="cov8" title="1">if assignment.Status != "" </span><span class="cov8" title="1">{
                update["status"] = assignment.Status
        }</span>
        <span class="cov8" title="1">if assignment.GracePeriod &gt; 0 </span><span class="cov8" title="1">{
                update["grace_period"] = assignment.GracePeriod
        }</span>
        <span class="cov8" title="1">if len(assignment.SubmissionRules) &gt; 0 </span><span class="cov8" title="1">{
                update["submission_rules"] = assignment.SubmissionRules
        }</span>
        <span class="cov8" title="1">if assignment.Instructions != "" </span><span class="cov8" title="1">{
                update["instructions"] = assignment.Instructions
        }</span>
        <span class="cov8" title="1">if len(assignment.Questions) &gt; 0 </span><span class="cov8" title="1">{
                update["questions"] = assignment.Questions
        }</span>
        <span class="cov8" title="1">if assignment.TotalPoints &gt; 0 </span><span class="cov8" title="1">{
                update["total_points"] = assignment.TotalPoints
        }</span>
        <span class="cov8" title="1">if assignment.PassingScore &gt; 0 </span><span class="cov8" title="1">{
                update["passing_score"] = assignment.PassingScore
        }</span>
        <span class="cov8" title="1">update["updated_at"] = primitive.NewDateTimeFromTime(time.Now())

        return update</span>
}

func (r *AssignmentRepository) UpdateAssignment(id string, updateAssignment model.Assignment) (*model.Assignment, error) <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update assignment: %v", err)
        }</span>

        <span class="cov8" title="1">update := filterEmptyAssignmentFields(updateAssignment)

        _, err = r.assignmentCollection.UpdateOne(context.TODO(), bson.M{"_id": objectId}, bson.M{"$set": update})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update assignment: %v", err)
        }</span>

        <span class="cov8" title="1">updatedAssignment, err := r.GetByID(context.TODO(), id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get updated assignment: %v", err)
        }</span>

        <span class="cov8" title="1">return updatedAssignment, nil</span>
}

func (r *AssignmentRepository) DeleteAssignment(id string) error <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete assignment: %v", err)
        }</span>

        <span class="cov8" title="1">_, err = r.assignmentCollection.DeleteOne(context.TODO(), bson.M{"_id": objectId})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete assignment: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "courses-service/src/schemas"
        "errors"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"

        "reflect"
)

type CourseRepository struct {
        db                   *mongo.Client
        dbName               string
        courseCollection     *mongo.Collection
        enrollmentCollection *mongo.Collection
}

func filterEmptyFields(course model.Course) any <span class="cov8" title="1">{
        updates := bson.D{}

        courseType := reflect.TypeOf(course)
        courseValue := reflect.ValueOf(course)

        for i := 0; i &lt; courseType.NumField(); i++ </span><span class="cov8" title="1">{
                field := courseType.Field(i)
                fieldValue := courseValue.Field(i)
                tag := field.Tag.Get("json")
                if !isZeroType(fieldValue) </span><span class="cov8" title="1">{
                        update := bson.E{Key: tag, Value: fieldValue.Interface()}
                        updates = append(updates, update)
                }</span>
        }

        <span class="cov8" title="1">return updates</span>
}

func isZeroType(value reflect.Value) bool <span class="cov8" title="1">{
        zero := reflect.Zero(value.Type()).Interface()

        switch value.Kind() </span>{
        case reflect.Slice, reflect.Array, reflect.Chan, reflect.Map:<span class="cov8" title="1">
                return value.Len() == 0</span>
        case reflect.String:<span class="cov8" title="1">
                return value.String() == ""</span>
        case reflect.Int:<span class="cov8" title="1">
                return value.Int() == 0</span>
        case reflect.Bool:<span class="cov0" title="0">
                return !value.Bool()</span>
        case reflect.Float64:<span class="cov0" title="0">
                return value.Float() == 0</span>
        default:<span class="cov8" title="1">
                return reflect.DeepEqual(zero, value.Interface())</span>
        }
}

func NewCourseRepository(db *mongo.Client, dbName string) *CourseRepository <span class="cov8" title="1">{
        return &amp;CourseRepository{
                db:                   db,
                dbName:               dbName,
                courseCollection:     db.Database(dbName).Collection("courses"),
                enrollmentCollection: db.Database(dbName).Collection("enrollments"),
        }
}</span>

func (r *CourseRepository) CreateCourse(course model.Course) (*model.Course, error) <span class="cov8" title="1">{
        result, err := r.courseCollection.InsertOne(context.TODO(), course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create course: %v", err)
        }</span>

        <span class="cov8" title="1">course.ID = result.InsertedID.(primitive.ObjectID)
        return &amp;course, nil</span>
}

func (r *CourseRepository) GetCourses() ([]*model.Course, error) <span class="cov8" title="1">{
        cursor, err := r.courseCollection.Find(context.TODO(), bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get courses: %v", err)
        }</span>

        <span class="cov8" title="1">var courses []*model.Course
        if err := cursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get courses: %v", err)
        }</span>

        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) GetCourseById(id string) (*model.Course, error) <span class="cov8" title="1">{
        var course model.Course
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get course by id: %v", err)
        }</span>
        <span class="cov8" title="1">err = r.courseCollection.FindOne(context.TODO(), bson.M{"_id": objectId}).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get course by id: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;course, nil</span>
}

func (r *CourseRepository) GetCourseByTeacherId(teacherId string) ([]*model.Course, error) <span class="cov8" title="1">{
        cursor, err := r.courseCollection.Find(context.TODO(), bson.M{"teacher_uuid": teacherId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by teacher id: %v", err)
        }</span>

        <span class="cov8" title="1">var courses []*model.Course
        if err := cursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by teacher id: %v", err)
        }</span>
        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) GetCoursesByStudentId(studentId string) ([]*model.Course, error) <span class="cov8" title="1">{
        // First, get all enrollment records for this student
        cursor, err := r.enrollmentCollection.Find(context.TODO(), bson.M{"student_id": studentId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get enrollments by student id: %v", err)
        }</span>

        // Parse enrollments to get course IDs
        <span class="cov8" title="1">var enrollments []model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse enrollments: %v", err)
        }</span>

        <span class="cov8" title="1">if len(enrollments) == 0 </span><span class="cov8" title="1">{
                return []*model.Course{}, nil
        }</span>

        // Extract course IDs from enrollments
        <span class="cov8" title="1">var courseIds []primitive.ObjectID
        for _, enrollment := range enrollments </span><span class="cov8" title="1">{
                courseId, err := primitive.ObjectIDFromHex(enrollment.CourseID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid course id in enrollment: %v", err)
                }</span>
                <span class="cov8" title="1">courseIds = append(courseIds, courseId)</span>
        }

        // Find all courses with these IDs
        <span class="cov8" title="1">filter := bson.M{"_id": bson.M{"$in": courseIds}}
        courseCursor, err := r.courseCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get courses by ids: %v", err)
        }</span>

        // Parse courses
        <span class="cov8" title="1">var courses []*model.Course
        if err := courseCursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse courses: %v", err)
        }</span>

        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) GetCourseByTitle(title string) ([]*model.Course, error) <span class="cov8" title="1">{
        filter := bson.M{
                "title": bson.M{
                        "$regex":   title,
                        "$options": "i",
                },
        }

        var courses []*model.Course
        cursor, err := r.courseCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by title: %v", err)
        }</span>

        <span class="cov8" title="1">if err := cursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by title: %v", err)
        }</span>

        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) DeleteCourse(id string) error <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete course: %v", err)
        }</span>
        <span class="cov8" title="1">_, err = r.courseCollection.DeleteOne(context.TODO(), bson.M{"_id": objectId})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete course: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *CourseRepository) UpdateCourse(id string, updateCourseRequest model.Course) (*model.Course, error) <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update course: %v", err)
        }</span>

        <span class="cov8" title="1">update := filterEmptyFields(updateCourseRequest)

        _, err = r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": objectId}, bson.M{"$set": update})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update course: %v", err)
        }</span>

        <span class="cov8" title="1">updatedCourse, err := r.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update course: %v", err)
        }</span>

        <span class="cov8" title="1">return updatedCourse, nil</span>
}

func (r *CourseRepository) AddAuxTeacherToCourse(course *model.Course, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        course.AuxTeachers = append(course.AuxTeachers, auxTeacherId)
        course.UpdatedAt = time.Now()

        // Direct MongoDB update to ensure we can set the exact AuxTeachers array
        update := bson.M{
                "$set": bson.M{
                        "aux_teachers": course.AuxTeachers,
                        "updated_at":   course.UpdatedAt,
                },
        }

        _, err := r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": course.ID}, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add aux teacher to course: %v", err)
        }</span>

        <span class="cov8" title="1">return r.GetCourseById(course.ID.Hex())</span>
}

func (r *CourseRepository) RemoveAuxTeacherFromCourse(course *model.Course, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        // Buscar y eliminar el auxTeacherId del slice
        for i, teacher := range course.AuxTeachers </span><span class="cov8" title="1">{
                if teacher == auxTeacherId </span><span class="cov8" title="1">{
                        // Eliminar el elemento del slice
                        course.AuxTeachers = append(course.AuxTeachers[:i], course.AuxTeachers[i+1:]...)
                        break</span>
                }
        }

        <span class="cov8" title="1">course.UpdatedAt = time.Now()

        // Direct MongoDB update to ensure we can set empty arrays
        update := bson.M{
                "$set": bson.M{
                        "aux_teachers": course.AuxTeachers,
                        "updated_at":   course.UpdatedAt,
                },
        }

        _, err := r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": course.ID}, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to remove aux teacher from course: %v", err)
        }</span>

        <span class="cov8" title="1">return r.GetCourseById(course.ID.Hex())</span>
}

func (r *CourseRepository) UpdateStudentsAmount(courseID string, newStudentsAmount int) error <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update students amount: %v", err)
        }</span>

        // Direct MongoDB update to ensure we can set StudentsAmount to 0
        <span class="cov8" title="1">update := bson.M{
                "$set": bson.M{
                        "students_amount": newStudentsAmount,
                        "updated_at":      time.Now(),
                },
        }

        _, err = r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": objectId}, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update students amount: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *CourseRepository) CreateCourseFeedback(courseID string, feedback model.CourseFeedback) (*model.CourseFeedback, error) <span class="cov8" title="1">{
        feedback.ID = primitive.NewObjectID()

        course, err := r.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if course.Feedback == nil </span><span class="cov0" title="0">{
                course.Feedback = []model.CourseFeedback{}
        }</span>

        <span class="cov8" title="1">course.Feedback = append(course.Feedback, feedback)

        _, err = r.UpdateCourse(course.ID.Hex(), *course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;feedback, nil</span>
}

func (r *CourseRepository) matchesFeedbackFilters(feedback *model.CourseFeedback, request schemas.GetCourseFeedbackRequest) bool <span class="cov8" title="1">{
        // Filter by feedback type
        if request.FeedbackType != "" &amp;&amp; feedback.FeedbackType != request.FeedbackType </span><span class="cov8" title="1">{
                return false
        }</span>

        // Filter by score range
        <span class="cov8" title="1">if request.StartScore != 0 &amp;&amp; feedback.Score &lt; request.StartScore </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if request.EndScore != 0 &amp;&amp; feedback.Score &gt; request.EndScore </span><span class="cov0" title="0">{
                return false
        }</span>

        // Filter by date range
        <span class="cov8" title="1">if !request.StartDate.IsZero() &amp;&amp; feedback.CreatedAt.Before(request.StartDate) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !request.EndDate.IsZero() &amp;&amp; feedback.CreatedAt.After(request.EndDate) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (r *CourseRepository) GetCourseFeedback(courseID string, getCourseFeedbackRequest schemas.GetCourseFeedbackRequest) ([]*model.CourseFeedback, error) <span class="cov8" title="1">{
        // Convert courseID to ObjectID
        objectId, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid course ID format: " + err.Error())
        }</span>

        // Get the course document
        <span class="cov8" title="1">var course model.Course
        err = r.courseCollection.FindOne(context.TODO(), bson.M{"_id": objectId}).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, errors.New("course not found")
                }</span>
                <span class="cov0" title="0">return nil, errors.New("error getting course: " + err.Error())</span>
        }

        // If course has no feedback, return empty slice
        <span class="cov8" title="1">if len(course.Feedback) == 0 </span><span class="cov8" title="1">{
                return []*model.CourseFeedback{}, nil
        }</span>

        // Apply filters to the feedback
        <span class="cov8" title="1">filteredFeedbacks := []*model.CourseFeedback{}
        for _, feedback := range course.Feedback </span><span class="cov8" title="1">{
                if r.matchesFeedbackFilters(&amp;feedback, getCourseFeedbackRequest) </span><span class="cov8" title="1">{
                        // Create a copy to avoid pointer issues
                        feedbackCopy := feedback
                        filteredFeedbacks = append(filteredFeedbacks, &amp;feedbackCopy)
                }</span>
        }

        <span class="cov8" title="1">return filteredFeedbacks, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "courses-service/src/schemas"
        "fmt"
        "log/slog"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type EnrollmentRepository struct {
        db                   *mongo.Client
        dbName               string
        enrollmentCollection *mongo.Collection
        courseRepository     *CourseRepository
}

func NewEnrollmentRepository(db *mongo.Client, dbName string, courseRepository *CourseRepository) *EnrollmentRepository <span class="cov8" title="1">{
        return &amp;EnrollmentRepository{db: db, dbName: dbName, enrollmentCollection: db.Database(dbName).Collection("enrollments"), courseRepository: courseRepository}
}</span>

func (r *EnrollmentRepository) createEnrollmentAndModifyCourseCapacity(enrollment model.Enrollment, course *model.Course, ctx context.Context) (interface{}, error) <span class="cov8" title="1">{
        res, err := r.enrollmentCollection.InsertOne(ctx, enrollment)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error creating enrollment", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">enrollment.ID = res.InsertedID.(primitive.ObjectID)

        err = r.courseRepository.UpdateStudentsAmount(course.ID.Hex(), course.StudentsAmount+1)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error updating course capacity", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return enrollment, nil</span>
}

func (r *EnrollmentRepository) CreateEnrollment(enrollment model.Enrollment, course *model.Course) error <span class="cov8" title="1">{
        _, err := r.createEnrollmentAndModifyCourseCapacity(enrollment, course, context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) GetEnrollmentsByCourseId(courseID string) ([]*model.Enrollment, error) <span class="cov8" title="1">{
        filter := bson.M{
                "course_id": courseID,
        }

        cursor, err := r.enrollmentCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var enrollments []*model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure we always return a non-nil slice
        <span class="cov8" title="1">if enrollments == nil </span><span class="cov8" title="1">{
                enrollments = []*model.Enrollment{}
        }</span>

        <span class="cov8" title="1">return enrollments, nil</span>
}

func (r *EnrollmentRepository) IsEnrolled(studentID, courseID string) (bool, error) <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        var enrollment model.Enrollment
        err := r.enrollmentCollection.FindOne(context.TODO(), filter).Decode(&amp;enrollment)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

func (r *EnrollmentRepository) deleteEnrollmentAndModifyCourseCapacity(studentID string, course *model.Course, ctx context.Context) error <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  course.ID.Hex(),
        }

        result, err := r.enrollmentCollection.DeleteOne(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Only update course capacity if we actually deleted an enrollment
        <span class="cov8" title="1">if result.DeletedCount &gt; 0 </span><span class="cov8" title="1">{
                err = r.courseRepository.UpdateStudentsAmount(course.ID.Hex(), course.StudentsAmount-1)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) DeleteEnrollment(studentID string, course *model.Course) error <span class="cov8" title="1">{
        err := r.deleteEnrollmentAndModifyCourseCapacity(studentID, course, context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) SetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        update := bson.M{
                "$set": bson.M{
                        "favourite": true,
                },
        }

        res, err := r.enrollmentCollection.UpdateOne(context.TODO(), filter, update)
        if res.MatchedCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("enrollment not found for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error setting favourite course for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) UnsetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        update := bson.M{
                "$set": bson.M{
                        "favourite": false,
                },
        }

        res, err := r.enrollmentCollection.UpdateOne(context.TODO(), filter, update)
        if res.MatchedCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("enrollment not found for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unsetting favourite course for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) GetEnrollmentByStudentIdAndCourseId(studentID, courseID string) (*model.Enrollment, error) <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        var enrollment model.Enrollment
        err := r.enrollmentCollection.FindOne(context.TODO(), filter).Decode(&amp;enrollment)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;enrollment, nil</span>
}

func (r *EnrollmentRepository) GetEnrollmentsByStudentId(studentID string) ([]*model.Enrollment, error) <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
        }

        cursor, err := r.enrollmentCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return []*model.Enrollment{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var enrollments []*model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return enrollments, nil</span>
}

func (r *EnrollmentRepository) CreateStudentFeedback(feedbackRequest model.StudentFeedback, enrollmentID string) error <span class="cov8" title="1">{
        feedbackRequest.ID = primitive.NewObjectID()

        // Convert string ID to ObjectID
        objID, err := primitive.ObjectIDFromHex(enrollmentID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid enrollment ID: %v", err)
        }</span>

        <span class="cov8" title="1">_, err = r.enrollmentCollection.UpdateOne(context.TODO(), bson.M{"_id": objID}, bson.M{"$push": bson.M{"feedback": feedbackRequest}})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) matchesFeedbackFilters(feedback *model.StudentFeedback, request schemas.GetFeedbackByStudentIdRequest) bool <span class="cov8" title="1">{
        // Filter by feedback type
        if request.FeedbackType != "" &amp;&amp; feedback.FeedbackType != request.FeedbackType </span><span class="cov8" title="1">{
                return false
        }</span>

        // Filter by score range
        <span class="cov8" title="1">if request.StartScore != 0 &amp;&amp; feedback.Score &lt; request.StartScore </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if request.EndScore != 0 &amp;&amp; feedback.Score &gt; request.EndScore </span><span class="cov0" title="0">{
                return false
        }</span>

        // Filter by date range
        <span class="cov8" title="1">if !request.StartDate.IsZero() &amp;&amp; feedback.CreatedAt.Before(request.StartDate) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !request.EndDate.IsZero() &amp;&amp; feedback.CreatedAt.After(request.EndDate) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (r *EnrollmentRepository) GetFeedbackByStudentId(studentID string, getFeedbackByStudentIdRequest schemas.GetFeedbackByStudentIdRequest) ([]*model.StudentFeedback, error) <span class="cov8" title="1">{
        // Build base filter for enrollments of the student
        filter := bson.M{
                "student_id": studentID,
                "feedback":   bson.M{"$exists": true, "$ne": []interface{}{}}, // Must have non-empty feedback array
        }

        // Add course filter if specified
        if getFeedbackByStudentIdRequest.CourseID != "" </span><span class="cov8" title="1">{
                filter["course_id"] = getFeedbackByStudentIdRequest.CourseID
        }</span>

        // Find all enrollments for this student
        <span class="cov8" title="1">cursor, err := r.enrollmentCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return []*model.StudentFeedback{}, nil // Return empty slice on error instead of nil
        }</span>
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var enrollments []*model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return []*model.StudentFeedback{}, nil // Return empty slice on error instead of nil
        }</span>

        // Extract and filter feedbacks from enrollments
        <span class="cov8" title="1">var allFeedbacks []*model.StudentFeedback
        for _, enrollment := range enrollments </span><span class="cov8" title="1">{
                for _, feedback := range enrollment.Feedback </span><span class="cov8" title="1">{
                        // Apply feedback filters
                        if r.matchesFeedbackFilters(&amp;feedback, getFeedbackByStudentIdRequest) </span><span class="cov8" title="1">{
                                // Create a copy to avoid pointer issues
                                feedbackCopy := feedback
                                allFeedbacks = append(allFeedbacks, &amp;feedbackCopy)
                        }</span>
                }
        }

        // Ensure we always return a non-nil slice
        <span class="cov8" title="1">if allFeedbacks == nil </span><span class="cov8" title="1">{
                allFeedbacks = []*model.StudentFeedback{}
        }</span>

        <span class="cov8" title="1">return allFeedbacks, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "fmt"
        "sort"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type ModuleRepository struct {
        db               *mongo.Client
        dbName           string
        moduleCollection *mongo.Collection
}

func NewModuleRepository(db *mongo.Client, dbName string) *ModuleRepository <span class="cov8" title="1">{
        return &amp;ModuleRepository{db: db, dbName: dbName, moduleCollection: db.Database(dbName).Collection("courses")}
}</span>

func (r *ModuleRepository) GetNextModuleOrder(courseID string) (int, error) <span class="cov8" title="1">{
        var course model.Course
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid course ID: %v", err)
        }</span>
        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID}
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to find course: %v", err)
        }</span>

        <span class="cov8" title="1">maxOrder := 0
        for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.Order &gt; maxOrder </span><span class="cov8" title="1">{
                        maxOrder = module.Order
                }</span>
        }

        <span class="cov8" title="1">return maxOrder + 1, nil</span>
}

func (r *ModuleRepository) CreateModule(courseID string, module model.Module) (*model.Module, error) <span class="cov8" title="1">{
        module.ID = primitive.NewObjectID()

        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID}
        update := bson.M{"$push": bson.M{"modules": module}}

        var course model.Course
        err = r.moduleCollection.FindOneAndUpdate(context.TODO(), filter, update).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create module: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;module, nil</span>
}

// reorderModules adjusts the order of modules when a module's position changes
func (r *ModuleRepository) reorderModules(modules []model.Module, targetModuleID primitive.ObjectID, newOrder int, oldOrder int) <span class="cov8" title="1">{
        for i := range modules </span><span class="cov8" title="1">{
                if modules[i].ID == targetModuleID </span><span class="cov8" title="1">{
                        // This is the target module, set its new order
                        modules[i].Order = newOrder
                }</span> else<span class="cov8" title="1"> {
                        // Adjust order for other modules
                        currentOrder := modules[i].Order

                        if oldOrder &lt; newOrder </span><span class="cov0" title="0">{
                                // Module moved down: shift modules between oldOrder+1 and newOrder up
                                if currentOrder &gt; oldOrder &amp;&amp; currentOrder &lt;= newOrder </span><span class="cov0" title="0">{
                                        modules[i].Order = currentOrder - 1
                                }</span>
                        } else<span class="cov8" title="1"> if oldOrder &gt; newOrder </span><span class="cov8" title="1">{
                                // Module moved up: shift modules between newOrder and oldOrder-1 down
                                if currentOrder &gt;= newOrder &amp;&amp; currentOrder &lt; oldOrder </span><span class="cov8" title="1">{
                                        modules[i].Order = currentOrder + 1
                                }</span>
                        }
                }
        }
}

// updateModuleFields updates the non-order fields of a target module
func (r *ModuleRepository) updateModuleFields(modules []model.Module, targetModuleID primitive.ObjectID, updatedModule model.Module) <span class="cov8" title="1">{
        for i := range modules </span><span class="cov8" title="1">{
                if modules[i].ID == targetModuleID </span><span class="cov8" title="1">{
                        if updatedModule.Title != "" </span><span class="cov8" title="1">{
                                modules[i].Title = updatedModule.Title
                        }</span>
                        <span class="cov8" title="1">if updatedModule.Description != "" </span><span class="cov8" title="1">{
                                modules[i].Description = updatedModule.Description
                        }</span>
                        <span class="cov8" title="1">if updatedModule.Content != "" </span><span class="cov8" title="1">{
                                modules[i].Content = updatedModule.Content
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
}

func (r *ModuleRepository) UpdateModule(id string, module model.Module) (*model.Module, error) <span class="cov8" title="1">{
        moduleUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid module ID: %v", err)
        }</span>

        // First, get the current module and course to check if order has changed
        <span class="cov8" title="1">filter := bson.M{"modules._id": moduleUUID}
        var currentCourse model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;currentCourse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find module: %v", err)
        }</span>

        // Find the current module
        <span class="cov8" title="1">var currentModule *model.Module
        for _, mod := range currentCourse.Modules </span><span class="cov8" title="1">{
                if mod.ID == moduleUUID </span><span class="cov8" title="1">{
                        currentModule = &amp;mod
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentModule == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("module not found")
        }</span>

        // Check if order has changed
        <span class="cov8" title="1">if module.Order != 0 &amp;&amp; module.Order != currentModule.Order </span><span class="cov8" title="1">{
                // Update module fields first
                r.updateModuleFields(currentCourse.Modules, moduleUUID, module)

                // Reorder modules
                r.reorderModules(currentCourse.Modules, moduleUUID, module.Order, currentModule.Order)

                // Sort modules by order to maintain consistency
                sort.Slice(currentCourse.Modules, func(i, j int) bool </span><span class="cov8" title="1">{
                        return currentCourse.Modules[i].Order &lt; currentCourse.Modules[j].Order
                }</span>)

                // Update the entire course with reordered modules
                <span class="cov8" title="1">courseFilter := bson.M{"_id": currentCourse.ID}
                update := bson.M{"$set": bson.M{"modules": currentCourse.Modules}}

                _, err = r.moduleCollection.UpdateOne(context.TODO(), courseFilter, update)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update module order: %v", err)
                }</span>

                // Return the updated module
                <span class="cov8" title="1">for _, mod := range currentCourse.Modules </span><span class="cov8" title="1">{
                        if mod.ID == moduleUUID </span><span class="cov8" title="1">{
                                return &amp;mod, nil
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // No order change, just update the specific module fields
                updateFields := bson.M{}
                if module.Title != "" </span><span class="cov8" title="1">{
                        updateFields["modules.$.title"] = module.Title
                }</span>
                <span class="cov8" title="1">if module.Description != "" </span><span class="cov8" title="1">{
                        updateFields["modules.$.description"] = module.Description
                }</span>
                <span class="cov8" title="1">if module.Content != "" </span><span class="cov8" title="1">{
                        updateFields["modules.$.content"] = module.Content
                }</span>

                <span class="cov8" title="1">if len(updateFields) &gt; 0 </span><span class="cov8" title="1">{
                        update := bson.M{"$set": updateFields}
                        _, err = r.moduleCollection.UpdateOne(context.TODO(), filter, update)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update module: %v", err)
                        }</span>
                }

                // Get the updated course to return the module
                <span class="cov8" title="1">err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;currentCourse)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find updated module: %v", err)
                }</span>

                // Return the updated module
                <span class="cov8" title="1">for _, mod := range currentCourse.Modules </span><span class="cov8" title="1">{
                        if mod.ID == moduleUUID </span><span class="cov8" title="1">{
                                return &amp;mod, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module not found after update")</span>
}

func (r *ModuleRepository) DeleteModule(id string) error <span class="cov8" title="1">{
        moduleUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid module ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"modules._id": moduleUUID}
        update := bson.M{"$pull": bson.M{"modules": bson.M{"_id": moduleUUID}}}

        var course model.Course
        err = r.moduleCollection.FindOneAndUpdate(context.TODO(), filter, update).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete module: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ModuleRepository) GetModuleByName(courseID string, moduleName string) (*model.Module, error) <span class="cov8" title="1">{
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID, "modules.title": moduleName}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find course or module: %v", err)
        }</span>

        // Find the module with the specified name
        <span class="cov8" title="1">for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.Title == moduleName </span><span class="cov8" title="1">{
                        return &amp;module, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module with name %s not found in course %s", moduleName, courseID)</span>
}

func (r *ModuleRepository) GetModuleById(id string) (*model.Module, error) <span class="cov8" title="1">{
        moduleUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid module ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"modules._id": moduleUUID}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find course or module: %v", err)
        }</span>

        // Find the module with the specified ID
        <span class="cov8" title="1">for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.ID == moduleUUID </span><span class="cov8" title="1">{
                        return &amp;module, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module with ID %s not found", id)</span>
}

func (r *ModuleRepository) GetModulesByCourseId(courseID string) ([]model.Module, error) <span class="cov8" title="1">{
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find course: %v", err)
        }</span>

        // Sort modules by order before returning
        <span class="cov8" title="1">sort.Slice(course.Modules, func(i, j int) bool </span><span class="cov8" title="1">{
                return course.Modules[i].Order &lt; course.Modules[j].Order
        }</span>)

        <span class="cov8" title="1">return course.Modules, nil</span>
}

func (r *ModuleRepository) GetModuleByOrder(courseID string, order int) (*model.Module, error) <span class="cov8" title="1">{
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID, "modules.order": order}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find course: %v", err)
        }</span>

        <span class="cov8" title="1">for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.Order == order </span><span class="cov8" title="1">{
                        return &amp;module, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module with order %d not found in course %s", order, courseID)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "context"

        "courses-service/src/model"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type MongoSubmissionRepository struct {
        collection *mongo.Collection
}

func NewMongoSubmissionRepository(db *mongo.Database) SubmissionRepositoryInterface <span class="cov8" title="1">{
        return &amp;MongoSubmissionRepository{
                collection: db.Collection("submissions"),
        }
}</span>

func (r *MongoSubmissionRepository) Create(ctx context.Context, submission *model.Submission) error <span class="cov8" title="1">{
        result, err := r.collection.InsertOne(ctx, submission)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">submission.ID = result.InsertedID.(primitive.ObjectID)
        return nil</span>
}

func (r *MongoSubmissionRepository) Update(ctx context.Context, submission *model.Submission) error <span class="cov8" title="1">{
        filter := bson.M{"_id": submission.ID}
        _, err := r.collection.ReplaceOne(ctx, filter, submission)
        return err
}</span>

func (r *MongoSubmissionRepository) GetByID(ctx context.Context, id string) (*model.Submission, error) <span class="cov8" title="1">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var submission model.Submission
        err = r.collection.FindOne(ctx, bson.M{"_id": objectID}).Decode(&amp;submission)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;submission, nil</span>
}

func (r *MongoSubmissionRepository) GetByAssignmentAndStudent(ctx context.Context, assignmentID, studentUUID string) (*model.Submission, error) <span class="cov8" title="1">{
        var submission model.Submission
        err := r.collection.FindOne(ctx, bson.M{
                "assignment_id": assignmentID,
                "student_uuid":  studentUUID,
        }).Decode(&amp;submission)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;submission, nil</span>
}

func (r *MongoSubmissionRepository) GetByAssignment(ctx context.Context, assignmentID string) ([]model.Submission, error) <span class="cov8" title="1">{
        cursor, err := r.collection.Find(ctx, bson.M{"assignment_id": assignmentID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        var submissions []model.Submission = make([]model.Submission, 0)
        if err = cursor.All(ctx, &amp;submissions); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return submissions, nil</span>
}

func (r *MongoSubmissionRepository) GetByStudent(ctx context.Context, studentUUID string) ([]model.Submission, error) <span class="cov8" title="1">{
        cursor, err := r.collection.Find(ctx, bson.M{"student_uuid": studentUUID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        var submissions []model.Submission = make([]model.Submission, 0)
        if err = cursor.All(ctx, &amp;submissions); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return submissions, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package router

import (
        "courses-service/src/config"
        "courses-service/src/controller"
        "courses-service/src/database"
        "courses-service/src/middleware"
        "courses-service/src/repository"
        "courses-service/src/service"
        "log"
        "log/slog"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"

        nrgin "github.com/newrelic/go-agent/v3/integrations/nrgin"
        "github.com/newrelic/go-agent/v3/newrelic"
)

func createRouterFromConfig(config *config.Config) *gin.Engine <span class="cov8" title="1">{
        if config.Environment == "production" </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span> else<span class="cov8" title="1"> {
                gin.SetMode(gin.DebugMode)
        }</span>

        <span class="cov8" title="1">r := gin.Default()
        return r</span>
}

func addNewRelicMiddleware(r *gin.Engine) <span class="cov8" title="1">{
        app, err := newrelic.NewApplication(
                newrelic.ConfigAppName("courses-service"),
                newrelic.ConfigLicense("35988c9ba24331e549191b23c94a4cb2FFFFNRAL"),
                newrelic.ConfigAppLogForwardingEnabled(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create NewRelic application: %v", err)
        }</span>

        <span class="cov8" title="1">r.Use(nrgin.Middleware(app))</span>
}

func InitializeCoursesRoutes(r *gin.Engine, controller *controller.CourseController) <span class="cov8" title="1">{
        r.GET("/courses", controller.GetCourses)
        r.POST("/courses", controller.CreateCourse)
        r.GET("/courses/teacher/:teacherId", controller.GetCourseByTeacherId)
        r.GET("/courses/student/:studentId", controller.GetCoursesByStudentId)
        r.GET("/courses/student/:studentId/favourite", controller.GetFavouriteCourses)
        r.GET("/courses/user/:userId", controller.GetCoursesByUserId)
        r.GET("/courses/title/:title", controller.GetCourseByTitle)
        r.GET("/courses/:id", controller.GetCourseById)
        r.DELETE("/courses/:id", controller.DeleteCourse)
        r.PUT("/courses/:id", controller.UpdateCourse)
        r.POST("/courses/:id/aux-teacher/add", controller.AddAuxTeacherToCourse)
        r.DELETE("/courses/:id/aux-teacher/remove", controller.RemoveAuxTeacherFromCourse)
        r.POST("/courses/:id/feedback", controller.CreateCourseFeedback)
        r.GET("/courses/:id/feedback", controller.GetCourseFeedback)
}</span>

func InitializeModulesRoutes(r *gin.Engine, controller *controller.ModuleController) <span class="cov8" title="1">{
        r.POST("/modules", controller.CreateModule)
        r.GET("/modules/course/:courseId", controller.GetModulesByCourseId)
        r.GET("/modules/:id", controller.GetModuleById)
        r.DELETE("/modules/:id", controller.DeleteModule)
        r.PUT("/modules/:id", controller.UpdateModule)
}</span>

func InitializeAssignmentsRoutes(r *gin.Engine, controller *controller.AssignmentsController) <span class="cov8" title="1">{
        r.GET("/assignments", controller.GetAssignments)
        r.POST("/assignments", controller.CreateAssignment)
        r.GET("/assignments/course/:courseId", controller.GetAssignmentsByCourseId)
        r.GET("/assignments/:assignmentId", controller.GetAssignmentById)
        r.PUT("/assignments/:assignmentId", controller.UpdateAssignment)
        r.DELETE("/assignments/:assignmentId", controller.DeleteAssignment)
}</span>

func InitializeSubmissionRoutes(r *gin.Engine, controller *controller.SubmissionController) <span class="cov8" title="1">{
        // Aplicar el middleware de autenticación de estudiantes
        studentAuthGroup := r.Group("")
        studentAuthGroup.Use(middleware.StudentAuth())

        studentAuthGroup.POST("/assignments/:assignmentId/submissions", controller.CreateSubmission)
        studentAuthGroup.GET("/assignments/:assignmentId/submissions/:id", controller.GetSubmission)
        studentAuthGroup.PUT("/assignments/:assignmentId/submissions/:id", controller.UpdateSubmission)
        studentAuthGroup.POST("/assignments/:assignmentId/submissions/:id/submit", controller.SubmitSubmission)
        studentAuthGroup.GET("/students/:studentUUID/submissions", controller.GetSubmissionsByStudent)

        // Aplicar el middleware de autenticación de docentes para calificar
        teacherAuthGroup := r.Group("")
        teacherAuthGroup.Use(middleware.TeacherAuth())
        teacherAuthGroup.PUT("/assignments/:assignmentId/submissions/:id/grade", controller.GradeSubmission)

        // Esta ruta no requiere autenticación de estudiante
        r.GET("/assignments/:assignmentId/submissions", controller.GetSubmissionsByAssignment)
}</span>

func InitializeEnrollmentsRoutes(r *gin.Engine, controller *controller.EnrollmentController) <span class="cov8" title="1">{
        r.GET("/courses/:id/enrollments", controller.GetEnrollmentsByCourseId)
        r.POST("/courses/:id/enroll", controller.EnrollStudent)
        r.DELETE("/courses/:id/unenroll", controller.UnenrollStudent)
        r.POST("/courses/:id/favourite", controller.SetFavouriteCourse)
        r.DELETE("/courses/:id/favourite", controller.UnsetFavouriteCourse)
        r.POST("/courses/:id/student-feedback", controller.CreateFeedback)
        r.GET("/feedback/student/:id", controller.GetFeedbackByStudentId)

}</span>

func NewRouter(config *config.Config) *gin.Engine <span class="cov8" title="1">{
        r := createRouterFromConfig(config)
        addNewRelicMiddleware(r)

        slog.Debug("Connecting to database")

        dbClient, err := database.NewMongoDBClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>

        <span class="cov8" title="1">slog.Debug("Connected to database")

        courseRepo := repository.NewCourseRepository(dbClient, config.DBName)
        enrollmentRepo := repository.NewEnrollmentRepository(dbClient, config.DBName, courseRepo)
        assignmentRepository := repository.NewAssignmentRepository(dbClient, config.DBName)
        submissionRepository := repository.NewMongoSubmissionRepository(dbClient.Database(config.DBName))
        moduleRepository := repository.NewModuleRepository(dbClient, config.DBName)

        courseService := service.NewCourseService(courseRepo, enrollmentRepo)
        enrollmentService := service.NewEnrollmentService(enrollmentRepo, courseRepo)
        assignmentService := service.NewAssignmentService(assignmentRepository, courseService)
        submissionService := service.NewSubmissionService(submissionRepository, assignmentRepository, courseService)
        moduleService := service.NewModuleService(moduleRepository)

        courseController := controller.NewCourseController(courseService)
        enrollmentController := controller.NewEnrollmentController(enrollmentService)
        assignmentsController := controller.NewAssignmentsController(assignmentService)
        submissionController := controller.NewSubmissionController(submissionService) // TODO change this when interface is added
        moduleController := controller.NewModuleController(moduleService)

        InitializeRoutes(r, courseController, assignmentsController, submissionController, enrollmentController, moduleController)
        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler)) // endpoint to consult the swagger documentation
        return r</span>
}

func InitializeRoutes(
        r *gin.Engine,
        courseController *controller.CourseController,
        assignmentsController *controller.AssignmentsController,
        submissionController *controller.SubmissionController,
        enrollmentController *controller.EnrollmentController,
        moduleController *controller.ModuleController,
) <span class="cov8" title="1">{
        InitializeCoursesRoutes(r, courseController)
        InitializeSubmissionRoutes(r, submissionController)
        InitializeAssignmentsRoutes(r, assignmentsController)
        InitializeEnrollmentsRoutes(r, enrollmentController)
        InitializeModulesRoutes(r, moduleController)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "context"
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "errors"
        "time"
)

type AssignmentService struct {
        assignmentRepository repository.AssignmentRepositoryInterface
        courseService        CourseServiceInterface
}

func NewAssignmentService(assignmentRepository repository.AssignmentRepositoryInterface, courseService CourseServiceInterface) *AssignmentService <span class="cov8" title="1">{
        return &amp;AssignmentService{assignmentRepository: assignmentRepository, courseService: courseService}
}</span>

func (s *AssignmentService) GetAssignments() ([]*model.Assignment, error) <span class="cov8" title="1">{
        return s.assignmentRepository.GetAssignments()
}</span>

func (s *AssignmentService) GetAssignmentById(id string) (*model.Assignment, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.assignmentRepository.GetByID(context.TODO(), id)</span>
}

func (s *AssignmentService) CreateAssignment(c schemas.CreateAssignmentRequest) (*model.Assignment, error) <span class="cov8" title="1">{
        // Validate course exists
        course, err := s.courseService.GetCourseById(c.CourseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course == nil </span><span class="cov8" title="1">{
                return nil, errors.New("course not found")
        }</span>

        <span class="cov8" title="1">assignment := model.Assignment{
                Title:        c.Title,
                Description:  c.Description,
                Instructions: c.Instructions,
                Type:         c.Type,
                CourseID:     c.CourseID,
                DueDate:      c.DueDate,
                GracePeriod:  c.GracePeriod,
                Status:       c.Status,
                Questions:    c.Questions,
                TotalPoints:  c.TotalPoints,
                PassingScore: c.PassingScore,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        return s.assignmentRepository.CreateAssignment(assignment)</span>
}

func (s *AssignmentService) UpdateAssignment(id string, updateAssignmentRequest schemas.UpdateAssignmentRequest) (*model.Assignment, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>

        // Check if assignment exists
        <span class="cov8" title="1">existingAssignment, err := s.assignmentRepository.GetByID(context.TODO(), id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if existingAssignment == nil </span><span class="cov8" title="1">{
                return nil, errors.New("assignment not found")
        }</span>

        <span class="cov8" title="1">assignment := model.Assignment{
                Title:        updateAssignmentRequest.Title,
                Description:  updateAssignmentRequest.Description,
                Instructions: updateAssignmentRequest.Instructions,
                Type:         updateAssignmentRequest.Type,
                CourseID:     existingAssignment.CourseID,
                DueDate:      updateAssignmentRequest.DueDate,
                GracePeriod:  updateAssignmentRequest.GracePeriod,
                Status:       updateAssignmentRequest.Status,
                Questions:    updateAssignmentRequest.Questions,
                TotalPoints:  updateAssignmentRequest.TotalPoints,
                PassingScore: updateAssignmentRequest.PassingScore,
                UpdatedAt:    time.Now(),
        }

        return s.assignmentRepository.UpdateAssignment(id, assignment)</span>
}

func (s *AssignmentService) DeleteAssignment(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.assignmentRepository.DeleteAssignment(id)</span>
}

func (s *AssignmentService) GetAssignmentsByCourseId(courseId string) ([]*model.Assignment, error) <span class="cov8" title="1">{
        if courseId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("course id is required")
        }</span>
        <span class="cov8" title="1">return s.assignmentRepository.GetAssignmentsByCourseId(courseId)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "errors"
        "slices"
        "time"
)

type CourseService struct {
        courseRepository     repository.CourseRepositoryInterface
        enrollmentRepository repository.EnrollmentRepositoryInterface
}

func NewCourseService(courseRepository repository.CourseRepositoryInterface, enrollmentRepository repository.EnrollmentRepositoryInterface) *CourseService <span class="cov8" title="1">{
        return &amp;CourseService{courseRepository: courseRepository, enrollmentRepository: enrollmentRepository}
}</span>

func (s *CourseService) GetCourses() ([]*model.Course, error) <span class="cov8" title="1">{
        return s.courseRepository.GetCourses()
}</span>

func (s *CourseService) CreateCourse(c schemas.CreateCourseRequest) (*model.Course, error) <span class="cov8" title="1">{
        if c.Capacity &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("capacity must be greater than 0")
        }</span>
        //TODO: check teacher exists
        <span class="cov8" title="1">course := model.Course{
                Title:       c.Title,
                Description: c.Description,
                TeacherUUID: c.TeacherID,
                Capacity:    c.Capacity,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                StartDate:   c.StartDate,
                EndDate:     c.EndDate,
        }
        return s.courseRepository.CreateCourse(course)</span>
}

func (s *CourseService) GetCourseById(id string) (*model.Course, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCourseById(id)</span>
}

func (s *CourseService) DeleteCourse(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.DeleteCourse(id)</span>
}

func (s *CourseService) GetCourseByTeacherId(teacherId string) ([]*model.Course, error) <span class="cov8" title="1">{
        if teacherId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("teacherId is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCourseByTeacherId(teacherId)</span>
}

func (s *CourseService) GetCoursesByStudentId(studentId string) ([]*model.Course, error) <span class="cov8" title="1">{
        if studentId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("studentId is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCoursesByStudentId(studentId)</span>
}

func (s *CourseService) GetCoursesByUserId(userId string) (*schemas.GetCoursesByUserIdResponse, error) <span class="cov8" title="1">{
        if userId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("userId is required")
        }</span>
        <span class="cov8" title="1">result := schemas.GetCoursesByUserIdResponse{}

        studentCourses, err := s.courseRepository.GetCoursesByStudentId(userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">teacherCourses, err := s.courseRepository.GetCourseByTeacherId(userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result.Student = studentCourses
        result.Teacher = teacherCourses

        return &amp;result, nil</span>
}

func (s *CourseService) GetCourseByTitle(title string) ([]*model.Course, error) <span class="cov8" title="1">{
        if title == "" </span><span class="cov8" title="1">{
                return nil, errors.New("title is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCourseByTitle(title)</span>
}

func (s *CourseService) UpdateCourse(id string, updateCourseRequest schemas.UpdateCourseRequest) (*model.Course, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>
        <span class="cov8" title="1">course := model.Course{
                Title:       updateCourseRequest.Title,
                Description: updateCourseRequest.Description,
                TeacherUUID: updateCourseRequest.TeacherID,
                Capacity:    updateCourseRequest.Capacity,
                UpdatedAt:   time.Now(),
        }
        return s.courseRepository.UpdateCourse(id, course)</span>
}

func (s *CourseService) AddAuxTeacherToCourse(id string, titularTeacherId string, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID != titularTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the teacher trying to add an aux teacher is not the owner of the course")
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID == auxTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the titular teacher cannot be an aux teacher for his own course")
        }</span>
        <span class="cov8" title="1">if slices.Contains(course.AuxTeachers, auxTeacherId) </span><span class="cov8" title="1">{
                return nil, errors.New("aux teacher already exists")
        }</span>
        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(auxTeacherId, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if enrolled </span><span class="cov0" title="0">{
                return nil, errors.New("the aux teacher is already enrolled in the course")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.AddAuxTeacherToCourse(course, auxTeacherId)</span>
}

func (s *CourseService) RemoveAuxTeacherFromCourse(id string, titularTeacherId string, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID != titularTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the teacher trying to remove an aux teacher is not the owner of the course")
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID == auxTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the titular teacher cannot be removed as aux teacher from his own course")
        }</span>
        <span class="cov8" title="1">if !slices.Contains(course.AuxTeachers, auxTeacherId) </span><span class="cov8" title="1">{
                return nil, errors.New("aux teacher is not assigned to this course")
        }</span>
        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(auxTeacherId, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if enrolled </span><span class="cov8" title="1">{
                return nil, errors.New("the aux teacher is already enrolled in the course")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.RemoveAuxTeacherFromCourse(course, auxTeacherId)</span>
}

func (s *CourseService) GetFavouriteCourses(studentId string) ([]*model.Course, error) <span class="cov8" title="1">{
        if studentId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("studentId is required")
        }</span>

        <span class="cov8" title="1">enrollments, err := s.enrollmentRepository.GetEnrollmentsByStudentId(studentId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">courses, err := s.courseRepository.GetCoursesByStudentId(studentId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">favouriteCourses := make([]*model.Course, 0)

        for _, course := range courses </span><span class="cov8" title="1">{
                for _, enrollment := range enrollments </span><span class="cov8" title="1">{
                        if enrollment.CourseID == course.ID.Hex() &amp;&amp; enrollment.Favourite </span><span class="cov8" title="1">{
                                favouriteCourses = append(favouriteCourses, course)
                        }</span>
                }
        }
        <span class="cov8" title="1">return favouriteCourses, nil</span>
}

func (s *CourseService) CreateCourseFeedback(courseId string, feedbackRequest schemas.CreateCourseFeedbackRequest) (*model.CourseFeedback, error) <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(courseId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if feedbackRequest.Score &lt; 1 || feedbackRequest.Score &gt; 5 </span><span class="cov8" title="1">{
                return nil, errors.New("score must be between 1 and 5")
        }</span>

        // Check if the student is the teacher or an aux teacher (should not be allowed to give feedback)
        <span class="cov8" title="1">if course.TeacherUUID == feedbackRequest.StudentUUID || slices.Contains(course.AuxTeachers, feedbackRequest.StudentUUID) </span><span class="cov8" title="1">{
                return nil, errors.New("the teacher cannot give feedback to his own course")
        }</span>

        <span class="cov8" title="1">if enrolled, err := s.enrollmentRepository.IsEnrolled(feedbackRequest.StudentUUID, courseId); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if !enrolled </span><span class="cov8" title="1">{
                return nil, errors.New("the student is not enrolled in the course")
        }</span>

        <span class="cov8" title="1">feedback := model.CourseFeedback{
                StudentUUID:  feedbackRequest.StudentUUID,
                FeedbackType: feedbackRequest.FeedbackType,
                Score:        feedbackRequest.Score,
                Feedback:     feedbackRequest.Feedback,
                CreatedAt:    time.Now(),
        }

        return s.courseRepository.CreateCourseFeedback(courseId, feedback)</span>
}

func (s *CourseService) GetCourseFeedback(courseId string, getCourseFeedbackRequest schemas.GetCourseFeedbackRequest) ([]*model.CourseFeedback, error) <span class="cov8" title="1">{
        _, err := s.courseRepository.GetCourseById(courseId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("course not found: " + err.Error())
        }</span>

        <span class="cov8" title="1">feedback, err := s.courseRepository.GetCourseFeedback(courseId, getCourseFeedbackRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("error getting course feedback: " + err.Error())
        }</span>

        <span class="cov8" title="1">return feedback, nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "fmt"
        "slices"
        "time"

        "go.mongodb.org/mongo-driver/mongo"
)

type EnrollmentService struct {
        enrollmentRepository repository.EnrollmentRepositoryInterface
        courseRepository     repository.CourseRepositoryInterface
}

func NewEnrollmentService(enrollmentRepository repository.EnrollmentRepositoryInterface, courseRepository repository.CourseRepositoryInterface) *EnrollmentService <span class="cov8" title="1">{
        return &amp;EnrollmentService{enrollmentRepository: enrollmentRepository, courseRepository: courseRepository}
}</span>

func (s *EnrollmentService) GetEnrollmentsByCourseId(courseID string) ([]*model.Enrollment, error) <span class="cov8" title="1">{
        if courseID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("course ID is required")
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("course %s not found", courseID)
        }</span>

        <span class="cov8" title="1">if course.StudentsAmount &lt;= 0 </span><span class="cov8" title="1">{
                return []*model.Enrollment{}, nil
        }</span>

        <span class="cov8" title="1">enrollments, err := s.enrollmentRepository.GetEnrollmentsByCourseId(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting enrollments by course ID: %v", err)
        }</span>

        <span class="cov8" title="1">return enrollments, nil</span>
}

func (s *EnrollmentService) EnrollStudent(studentID, courseID string) error <span class="cov8" title="1">{
        // First check if course exists
        course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for enrollment", courseID)
        }</span>

        // Then check if the course has the capacity to enroll more students
        <span class="cov8" title="1">if course.StudentsAmount &gt;= course.Capacity </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s is full", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot enroll in course %s", studentID, courseID)
        }</span>

        // Then check if the student is already enrolled in the course
        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is already enrolled in course %s", studentID, courseID)
        }</span>

        // Then create the enrollment
        <span class="cov8" title="1">enrollment := model.Enrollment{
                StudentID:  studentID,
                CourseID:   courseID,
                EnrolledAt: time.Now(),
                Status:     model.EnrollmentStatusActive,
                UpdatedAt:  time.Now(),
                Feedback:   []model.StudentFeedback{},
        }

        err = s.enrollmentRepository.CreateEnrollment(enrollment, course)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error creating enrollment for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) UnenrollStudent(studentID, courseID string) error <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for unenrollment", courseID)
        }</span>

        <span class="cov8" title="1">if course.StudentsAmount &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s is empty", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot unenroll from course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil &amp;&amp; err != mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if !enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is not enrolled in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">err = s.enrollmentRepository.DeleteEnrollment(studentID, course)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error deleting enrollment for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) SetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        if studentID == "" || courseID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("student ID and course ID are required")
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for favourite course", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot set favourite course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if !enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is not enrolled in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">err = s.enrollmentRepository.SetFavouriteCourse(studentID, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error setting favourite course for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) UnsetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        if studentID == "" || courseID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("student ID and course ID are required")
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for unset favourite course", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot unset favourite course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if !enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is not enrolled in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">err = s.enrollmentRepository.UnsetFavouriteCourse(studentID, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unsetting favourite course for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) GetEnrollmentByStudentIdAndCourseId(studentID, courseID string) (*model.Enrollment, error) <span class="cov8" title="1">{
        if studentID == "" || courseID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("student ID and course ID are required")
        }</span>

        <span class="cov8" title="1">enrollment, err := s.enrollmentRepository.GetEnrollmentByStudentIdAndCourseId(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting enrollment by student ID and course ID: %v", err)
        }</span>

        <span class="cov8" title="1">return enrollment, nil</span>
}

func (s *EnrollmentService) CreateStudentFeedback(feedbackRequest schemas.CreateStudentFeedbackRequest) error <span class="cov8" title="1">{
        if feedbackRequest.Score &lt; 1 || feedbackRequest.Score &gt; 5 </span><span class="cov8" title="1">{
                return fmt.Errorf("score must be between 1 and 5, not %d", feedbackRequest.Score)
        }</span>

        <span class="cov8" title="1">enrollment, err := s.GetEnrollmentByStudentIdAndCourseId(feedbackRequest.StudentUUID, feedbackRequest.CourseID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(feedbackRequest.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting course by ID: %v", err)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID != feedbackRequest.TeacherUUID &amp;&amp; !slices.Contains(course.AuxTeachers, feedbackRequest.TeacherUUID) </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s is not the teacher or aux teacher of course %s", feedbackRequest.TeacherUUID, feedbackRequest.CourseID)
        }</span>

        <span class="cov8" title="1">feedback := model.StudentFeedback{
                StudentUUID:  feedbackRequest.StudentUUID,
                TeacherUUID:  feedbackRequest.TeacherUUID,
                FeedbackType: feedbackRequest.FeedbackType,
                Score:        feedbackRequest.Score,
                Feedback:     feedbackRequest.Feedback,
                CreatedAt:    time.Now(),
        }

        err = s.enrollmentRepository.CreateStudentFeedback(feedback, enrollment.ID.Hex())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating student feedback: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) GetFeedbackByStudentId(studentID string, getFeedbackByStudentIdRequest schemas.GetFeedbackByStudentIdRequest) ([]*model.StudentFeedback, error) <span class="cov8" title="1">{
        if studentID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("student ID is required")
        }</span>

        <span class="cov8" title="1">feedback, err := s.enrollmentRepository.GetFeedbackByStudentId(studentID, getFeedbackByStudentIdRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting feedback by student ID: %v", err)
        }</span>

        <span class="cov8" title="1">return feedback, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "errors"
        "fmt"
        "log/slog"
)

type ModuleService struct {
        moduleRepository repository.ModuleRepositoryInterface
}

func NewModuleService(moduleRepository repository.ModuleRepositoryInterface) *ModuleService <span class="cov8" title="1">{
        return &amp;ModuleService{moduleRepository: moduleRepository}
}</span>

func (s *ModuleService) CreateModule(module schemas.CreateModuleRequest) (*model.Module, error) <span class="cov8" title="1">{
        fmt.Printf("Creating module: %v\n", module)
        if _, err := s.moduleRepository.GetModuleByName(module.CourseID, module.Title); err == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("module with title %s already exists in course %s", module.Title, module.CourseID)
        }</span>

        <span class="cov8" title="1">moduleModel := model.Module{
                Title:       module.Title,
                Description: module.Description,
                Content:     module.Content,
        }

        order, err := s.moduleRepository.GetNextModuleOrder(module.CourseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">moduleModel.Order = order

        return s.moduleRepository.CreateModule(module.CourseID, moduleModel)</span>
}

func (s *ModuleService) GetModulesByCourseId(courseId string) ([]model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Getting modules by course id", "courseId", courseId)
        if courseId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("courseId is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.GetModulesByCourseId(courseId)</span>
}

func (s *ModuleService) GetModuleById(id string) (*model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Getting module by id", "id", id)
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("module id is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.GetModuleById(id)</span>
}

func (s *ModuleService) GetModuleByOrder(courseID string, order int) (*model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Getting module by order", "courseID", courseID, "order", order)
        if courseID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("courseId is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.GetModuleByOrder(courseID, order)</span>
}
func (s *ModuleService) UpdateModule(id string, module model.Module) (*model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Updating module", "id", id, "module", module)
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("module id is required")
        }</span>

        <span class="cov8" title="1">existingModule, err := s.moduleRepository.GetModuleByName(module.CourseID, module.Title)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check if the module we are updating is the same as the existing module
        <span class="cov8" title="1">if existingModule.ID != module.ID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("module with title %s already exists in course %s", module.Title, module.CourseID)
        }</span>

        <span class="cov8" title="1">return s.moduleRepository.UpdateModule(id, module)</span>
}

func (s *ModuleService) DeleteModule(id string) error <span class="cov8" title="1">{
        slog.Debug("Deleting module", "id", id)
        if id == "" </span><span class="cov8" title="1">{
                return errors.New("module id is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.DeleteModule(id)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "context"
        "errors"
        "time"

        "courses-service/src/model"
        "courses-service/src/repository"
)

type SubmissionService struct {
        submissionRepo repository.SubmissionRepositoryInterface
        assignmentRepo repository.AssignmentRepositoryInterface
        courseService  CourseServiceInterface
}

func NewSubmissionService(submissionRepo repository.SubmissionRepositoryInterface, assignmentRepo repository.AssignmentRepositoryInterface, courseService CourseServiceInterface) *SubmissionService <span class="cov8" title="1">{
        return &amp;SubmissionService{
                submissionRepo: submissionRepo,
                assignmentRepo: assignmentRepo,
                courseService:  courseService,
        }
}</span>

func (s *SubmissionService) CreateSubmission(ctx context.Context, submission *model.Submission) error <span class="cov8" title="1">{
        // Get assignment to validate submission
        assignment, err := s.assignmentRepo.GetByID(ctx, submission.AssignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if assignment == nil </span><span class="cov8" title="1">{
                return ErrAssignmentNotFound
        }</span>

        // Initialize submission
        <span class="cov8" title="1">submission.CreatedAt = time.Now()
        submission.UpdatedAt = submission.CreatedAt
        submission.Status = model.SubmissionStatusDraft

        return s.submissionRepo.Create(ctx, submission)</span>
}

func (s *SubmissionService) UpdateSubmission(ctx context.Context, submission *model.Submission) error <span class="cov0" title="0">{
        existing, err := s.submissionRepo.GetByID(ctx, submission.ID.Hex())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if existing == nil </span><span class="cov0" title="0">{
                return ErrSubmissionNotFound
        }</span>

        <span class="cov0" title="0">submission.UpdatedAt = time.Now()
        return s.submissionRepo.Update(ctx, submission)</span>
}

func (s *SubmissionService) SubmitSubmission(ctx context.Context, submissionID string) error <span class="cov0" title="0">{
        submission, err := s.submissionRepo.GetByID(ctx, submissionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if submission == nil </span><span class="cov0" title="0">{
                return ErrSubmissionNotFound
        }</span>

        <span class="cov0" title="0">assignment, err := s.assignmentRepo.GetByID(ctx, submission.AssignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if assignment == nil </span><span class="cov0" title="0">{
                return ErrAssignmentNotFound
        }</span>

        <span class="cov0" title="0">now := time.Now()
        submission.SubmittedAt = &amp;now
        submission.UpdatedAt = now

        // Check if submission is late
        if now.After(assignment.DueDate) </span><span class="cov0" title="0">{
                gracePeriodEnd := assignment.DueDate.Add(time.Duration(assignment.GracePeriod) * time.Minute)
                if now.After(gracePeriodEnd) </span><span class="cov0" title="0">{
                        submission.Status = model.SubmissionStatusLate
                }</span>
        } else<span class="cov0" title="0"> {
                submission.Status = model.SubmissionStatusSubmitted
        }</span>

        <span class="cov0" title="0">return s.submissionRepo.Update(ctx, submission)</span>
}

func (s *SubmissionService) GetSubmission(ctx context.Context, id string) (*model.Submission, error) <span class="cov8" title="1">{
        return s.submissionRepo.GetByID(ctx, id)
}</span>

func (s *SubmissionService) GetSubmissionsByAssignment(ctx context.Context, assignmentID string) ([]model.Submission, error) <span class="cov0" title="0">{
        return s.submissionRepo.GetByAssignment(ctx, assignmentID)
}</span>

func (s *SubmissionService) GetSubmissionsByStudent(ctx context.Context, studentUUID string) ([]model.Submission, error) <span class="cov0" title="0">{
        return s.submissionRepo.GetByStudent(ctx, studentUUID)
}</span>

func (s *SubmissionService) GetOrCreateSubmission(ctx context.Context, assignmentID, studentUUID, studentName string) (*model.Submission, error) <span class="cov8" title="1">{
        submission, err := s.submissionRepo.GetByAssignmentAndStudent(ctx, assignmentID, studentUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if submission != nil </span><span class="cov8" title="1">{
                return submission, nil
        }</span>

        // Create new submission
        <span class="cov8" title="1">newSubmission := &amp;model.Submission{
                AssignmentID: assignmentID,
                StudentUUID:  studentUUID,
                StudentName:  studentName,
                Status:       model.SubmissionStatusDraft,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        err = s.submissionRepo.Create(ctx, newSubmission)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return newSubmission, nil</span>
}

// GradeSubmission updates the score and feedback of a submission
func (s *SubmissionService) GradeSubmission(ctx context.Context, submissionID string, score *float64, feedback string) (*model.Submission, error) <span class="cov8" title="1">{
        submission, err := s.submissionRepo.GetByID(ctx, submissionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                return nil, ErrSubmissionNotFound
        }</span>

        // Update submission with grading information
        <span class="cov8" title="1">submission.Score = score
        submission.Feedback = feedback
        submission.UpdatedAt = time.Now()

        err = s.submissionRepo.Update(ctx, submission)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return submission, nil</span>
}

// ValidateTeacherPermissions validates if a teacher can grade submissions for a given assignment
func (s *SubmissionService) ValidateTeacherPermissions(ctx context.Context, assignmentID, teacherUUID string) error <span class="cov8" title="1">{
        // Get assignment
        assignment, err := s.assignmentRepo.GetByID(ctx, assignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if assignment == nil </span><span class="cov8" title="1">{
                return ErrAssignmentNotFound
        }</span>

        // Get course
        <span class="cov8" title="1">course, err := s.courseService.GetCourseById(assignment.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if course == nil </span><span class="cov0" title="0">{
                return errors.New("course not found")
        }</span>

        // Check if teacher is the main teacher
        <span class="cov8" title="1">if course.TeacherUUID == teacherUUID </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check if teacher is an auxiliary teacher
        <span class="cov8" title="1">for _, auxTeacher := range course.AuxTeachers </span><span class="cov8" title="1">{
                if auxTeacher == teacherUUID </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return errors.New("teacher not authorized to grade this assignment")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package testutil

import (
        "context"
        "log"
        "os"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// DBSetup holds the MongoDB client and database name for testing
type DBSetup struct {
        Client *mongo.Client
        DBName string
}

// SetupTestDB initializes a MongoDB client for testing
func SetupTestDB() *DBSetup <span class="cov8" title="1">{
        ctx := context.Background()
        uri := os.Getenv("DB_URI")
        clientOptions := options.Client().ApplyURI(uri)
        client, err := mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">err = client.Ping(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">dbName := os.Getenv("DB_NAME")
        log.Printf("Initialized test database %s running on %s", dbName, uri)

        return &amp;DBSetup{
                Client: client,
                DBName: dbName,
        }</span>
}

// CleanupTestDB disconnects from the MongoDB client
func CleanupTestDB(client *mongo.Client) <span class="cov0" title="0">{
        if err := client.Disconnect(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error disconnecting from database: %v", err)
        }</span>
}

// CleanupCollection drops all documents from a collection
func (db *DBSetup) CleanupCollection(collection string) <span class="cov8" title="1">{
        coll := db.Client.Database(db.DBName).Collection(collection)
        _, err := coll.DeleteMany(context.Background(), bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error cleaning up collection %s: %v", collection, err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
