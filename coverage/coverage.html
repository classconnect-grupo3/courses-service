
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ai: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">courses-service/src/ai/ai_client.go (5.3%)</option>
				
				<option value="file1">courses-service/src/config/config.go (100.0%)</option>
				
				<option value="file2">courses-service/src/controller/assignments_controller.go (77.8%)</option>
				
				<option value="file3">courses-service/src/controller/courses_controller.go (88.9%)</option>
				
				<option value="file4">courses-service/src/controller/enrollment_controller.go (82.5%)</option>
				
				<option value="file5">courses-service/src/controller/forum_controller.go (85.6%)</option>
				
				<option value="file6">courses-service/src/controller/module_controller.go (100.0%)</option>
				
				<option value="file7">courses-service/src/controller/submission_controller.go (91.2%)</option>
				
				<option value="file8">courses-service/src/database/connection.go (71.4%)</option>
				
				<option value="file9">courses-service/src/main.go (0.0%)</option>
				
				<option value="file10">courses-service/src/middleware/student_auth.go (10.0%)</option>
				
				<option value="file11">courses-service/src/middleware/teacher_auth.go (10.0%)</option>
				
				<option value="file12">courses-service/src/repository/assignment_repository.go (87.0%)</option>
				
				<option value="file13">courses-service/src/repository/course_repository.go (82.4%)</option>
				
				<option value="file14">courses-service/src/repository/enrollment_repository.go (81.4%)</option>
				
				<option value="file15">courses-service/src/repository/forum_repository.go (87.1%)</option>
				
				<option value="file16">courses-service/src/repository/module_repository.go (89.9%)</option>
				
				<option value="file17">courses-service/src/repository/submission_repository.go (83.3%)</option>
				
				<option value="file18">courses-service/src/router/router.go (97.1%)</option>
				
				<option value="file19">courses-service/src/service/assignment_service.go (100.0%)</option>
				
				<option value="file20">courses-service/src/service/course_service.go (84.2%)</option>
				
				<option value="file21">courses-service/src/service/enrollment_service.go (96.2%)</option>
				
				<option value="file22">courses-service/src/service/forum_service.go (69.7%)</option>
				
				<option value="file23">courses-service/src/service/module_service.go (100.0%)</option>
				
				<option value="file24">courses-service/src/service/submission_service.go (53.2%)</option>
				
				<option value="file25">courses-service/src/tests/testutil/db_setup.go (72.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ai

import (
        "context"
        "encoding/json"
        "fmt"
        "log"

        "courses-service/src/config"
        "courses-service/src/model"

        "google.golang.org/genai"
)

type AiClient struct {
        context      context.Context
        GeminiApiKey string
        Client       *genai.Client
}

const aiModel = "gemini-2.0-flash"

func generateStudentFeedbacksPrompt(feedbacks []*model.StudentFeedback) string <span class="cov0" title="0">{
        prompt := SummarizeStudentFeedbacksPrompt
        for _, feedback := range feedbacks </span><span class="cov0" title="0">{
                prompt += fmt.Sprintf("Puntuacion: %d\n", feedback.Score)
                prompt += fmt.Sprintf("Tipo: %s\n", feedback.FeedbackType)
                prompt += fmt.Sprintf("Feedback: %s\n", feedback.Feedback)
        }</span>
        <span class="cov0" title="0">return prompt</span>
}

func generateCourseFeedbacksPrompt(feedbacks []*model.CourseFeedback) string <span class="cov0" title="0">{
        prompt := SummarizeCourseFeedbacksPrompt
        for _, feedback := range feedbacks </span><span class="cov0" title="0">{
                prompt += fmt.Sprintf("Puntuacion: %d\n", feedback.Score)
                prompt += fmt.Sprintf("Tipo: %s\n", feedback.FeedbackType)
                prompt += fmt.Sprintf("Feedback: %s\n", feedback.Feedback)
        }</span>
        <span class="cov0" title="0">return prompt</span>
}

func NewAiClient(config *config.Config) *AiClient <span class="cov8" title="1">{

        if config.Environment == "test" </span><span class="cov8" title="1">{
                return &amp;AiClient{
                        context:      context.Background(),
                        GeminiApiKey: "",
                        Client:       nil,
                }
        }</span>
        <span class="cov0" title="0">geminiApiKey := config.GeminiApiKey
        ctx := context.Background()
        client, err := genai.NewClient(ctx, &amp;genai.ClientConfig{
                APIKey: geminiApiKey,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to create Gemini client", err)
                return nil
        }</span>
        <span class="cov0" title="0">log.Println("Gemini client created")
        return &amp;AiClient{
                context:      ctx,
                GeminiApiKey: geminiApiKey,
                Client:       client,
        }</span>
}

func (c *AiClient) SummarizeCourseFeedbacks(feedbacks []*model.CourseFeedback) (string, error) <span class="cov0" title="0">{
        prompt := generateCourseFeedbacksPrompt(feedbacks)
        response, err := c.Client.Models.GenerateContent(c.context, aiModel, genai.Text(prompt), nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to generate content", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return debugString(response), nil</span>
}

func (c *AiClient) SummarizeStudentFeedbacks(feedbacks []*model.StudentFeedback) (string, error) <span class="cov0" title="0">{
        prompt := generateStudentFeedbacksPrompt(feedbacks)
        response, err := c.Client.Models.GenerateContent(c.context, aiModel, genai.Text(prompt), nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to generate content", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return debugString(response), nil</span>
}

func debugString[T any](r *T) string <span class="cov0" title="0">{

        response, err := json.MarshalIndent(*r, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return string(response)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import "os"

type Config struct {
        DBUsername   string
        DBPassword   string
        DBName       string
        DBURI        string
        Host         string
        Port         string
        Environment  string
        GeminiApiKey string
}

func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DBUsername:   os.Getenv("DB_USERNAME"),
                DBPassword:   os.Getenv("DB_PASSWORD"),
                DBName:       os.Getenv("DB_NAME"),
                DBURI:        os.Getenv("DB_URI"),
                Host:         os.Getenv("HOST"),
                Port:         os.Getenv("PORT"),
                Environment:  os.Getenv("ENVIRONMENT"),
                GeminiApiKey: os.Getenv("GEMINI_API_KEY"),
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "encoding/json"
        "log"
        "log/slog"
        "net/http"
        "os"
        "time"

        "courses-service/src/schemas"
        "courses-service/src/service"

        "github.com/gin-gonic/gin"
        "github.com/rabbitmq/amqp091-go"
)

type AssignmentsController struct {
        service service.AssignmentServiceInterface
}

func NewAssignmentsController(service service.AssignmentServiceInterface) *AssignmentsController <span class="cov8" title="1">{
        return &amp;AssignmentsController{service: service}
}</span>

// @Summary Get all assignments
// @Description Get all assignments
// @Tags assignments
// @Accept json
// @Produce json
// @Router /assignments [get]
// @Success 200 {array} model.Assignment
func (c *AssignmentsController) GetAssignments(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting assignments")

        assignments, err := c.service.GetAssignments()
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting assignments", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignments retrieved", "assignments", assignments)
        ctx.JSON(http.StatusOK, assignments)</span>
}

// @Summary Create an assignment
// @Description Create an assignment
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignment body schemas.CreateAssignmentRequest true "Assignment to create"
// @Success 201 {object} model.Assignment
// @Router /assignments [post]
func (c *AssignmentsController) CreateAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        log.Println("Creating assignment")

        var assignment schemas.CreateAssignmentRequest
        if err := ctx.ShouldBindJSON(&amp;assignment); err != nil </span><span class="cov8" title="1">{
                log.Println("Error binding JSON:", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">createdAssignment, err := c.service.CreateAssignment(assignment)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("Error creating assignment:", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // 🟡 Publicar evento en RabbitMQ con amqp091-go
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                conn, err := amqp091.Dial(os.Getenv("RABBITMQ_URL"))
                if err != nil </span><span class="cov8" title="1">{
                        log.Println("RabbitMQ connection error:", err)
                        return
                }</span>
                <span class="cov0" title="0">defer conn.Close()

                ch, err := conn.Channel()
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("RabbitMQ channel error:", err)
                        return
                }</span>
                <span class="cov0" title="0">defer ch.Close()

                _, err = ch.QueueDeclare(
                        os.Getenv("NOTIFICATIONS_QUEUE_NAME"),
                        false,
                        false,
                        false,
                        false,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Queue declare error:", err)
                        return
                }</span>

                <span class="cov0" title="0">event := map[string]interface{}{
                        "event_type":          "assignment.created",
                        "course_id":           createdAssignment.CourseID,
                        "assignment_id":       createdAssignment.ID,
                        "assignment_title":    createdAssignment.Title,
                        "assignment_due_date": createdAssignment.DueDate.Format(time.RFC3339),
                }

                body, err := json.Marshal(event)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Error marshaling event:", err)
                        return
                }</span>

                <span class="cov0" title="0">err = ch.Publish(
                        "",
                        os.Getenv("NOTIFICATIONS_QUEUE_NAME"),
                        false,
                        false,
                        amqp091.Publishing{
                                ContentType: "application/json",
                                Body:        body,
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Error publishing message:", err)
                        return
                }</span>

                <span class="cov0" title="0">log.Println("📤 Event published: assignment.created")</span>
        }()

        <span class="cov8" title="1">log.Println("Assignment created:", createdAssignment.ID)
        ctx.JSON(http.StatusCreated, createdAssignment)</span>
}

// @Summary Get an assignment by ID
// @Description Get an assignment by ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Success 200 {object} model.Assignment
// @Router /assignments/{assignmentId} [get]
func (c *AssignmentsController) GetAssignmentById(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting assignment by ID")
        id := ctx.Param("assignmentId")

        assignment, err := c.service.GetAssignmentById(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting assignment", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if assignment == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "assignment not found"})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignment retrieved", "assignment", assignment)
        ctx.JSON(http.StatusOK, assignment)</span>
}

// @Summary Get assignments by course ID
// @Description Get assignments by course ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param courseId path string true "Course ID"
// @Success 200 {array} model.Assignment
// @Router /assignments/course/{courseId} [get]
func (c *AssignmentsController) GetAssignmentsByCourseId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting assignments by course ID")
        courseId := ctx.Param("courseId")

        assignments, err := c.service.GetAssignmentsByCourseId(courseId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting assignments", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignments retrieved", "assignments", assignments)
        ctx.JSON(http.StatusOK, assignments)</span>
}

// @Summary Update an assignment
// @Description Update an assignment by ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param assignment body schemas.UpdateAssignmentRequest true "Assignment to update"
// @Success 200 {object} model.Assignment
// @Router /assignments/{assignmentId} [put]
func (c *AssignmentsController) UpdateAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating assignment")
        id := ctx.Param("assignmentId")

        var updateAssignmentRequest schemas.UpdateAssignmentRequest
        if err := ctx.ShouldBindJSON(&amp;updateAssignmentRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">updatedAssignment, err := c.service.UpdateAssignment(id, updateAssignmentRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating assignment", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignment updated", "assignment", updatedAssignment)
        ctx.JSON(http.StatusOK, updatedAssignment)</span>
}

// @Summary Delete an assignment
// @Description Delete an assignment by ID
// @Tags assignments
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Success 200 {string} string "Assignment deleted successfully"
// @Router /assignments/{assignmentId} [delete]
func (c *AssignmentsController) DeleteAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting assignment")
        id := ctx.Param("assignmentId")

        if err := c.service.DeleteAssignment(id); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error deleting assignment", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Assignment deleted")
        ctx.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "log/slog"
        "net/http"
        "slices"

        "courses-service/src/ai"
        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"

        "github.com/gin-gonic/gin"
)

type CourseController struct {
        service  service.CourseServiceInterface
        aiClient *ai.AiClient
}

func NewCourseController(service service.CourseServiceInterface, aiClient *ai.AiClient) *CourseController <span class="cov8" title="1">{
        return &amp;CourseController{service: service, aiClient: aiClient}
}</span>

// @Summary Get all courses
// @Description Get all courses available in the database
// @Tags courses
// @Accept json
// @Produce json
// @Success 200 {array} model.Course
// @Router /courses [get]
func (c *CourseController) GetCourses(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting courses")

        courses, err := c.service.GetCourses()
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting courses", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Course creation
// @Description Create a new course
// @Tags courses
// @Accept json
// @Produce json
// @Param course body schemas.CreateCourseRequest true "Course to create"
// @Success 201 {object} model.Course
// @Router /courses [post]
func (c *CourseController) CreateCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating course")

        var course schemas.CreateCourseRequest
        if err := ctx.ShouldBindJSON(&amp;course); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">createdCourse, err := c.service.CreateCourse(course)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course created", "course", createdCourse)
        ctx.JSON(http.StatusCreated, createdCourse)</span>
}

// @Summary Get a course by ID
// @Description Get a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {object} model.Course
// @Router /courses/{id} [get]
func (c *CourseController) GetCourseById(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course by ID")

        id := ctx.Param("id")
        course, err := c.service.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course by ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course retrieved", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Delete a course
// @Description Delete a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {object} schemas.DeleteCourseResponse
// @Router /courses/{id} [delete]
func (c *CourseController) DeleteCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting course")
        id := ctx.Param("id")

        err := c.service.DeleteCourse(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error deleting course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course deleted", "id", id)
        ctx.JSON(http.StatusOK, gin.H{"message": "Course deleted successfully"})</span>
}

// @Summary Get a course by teacher ID
// @Description Get a course by teacher ID
// @Tags courses
// @Accept json
// @Produce json
// @Param teacherId path string true "Teacher ID"
// @Success 200 {array} model.Course
// @Router /courses/teacher/{teacherId} [get]
func (c *CourseController) GetCourseByTeacherId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course by teacher ID")
        teacherId := ctx.Param("teacherId")
        course, err := c.service.GetCourseByTeacherId(teacherId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course by teacher ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course retrieved", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Get a course by title
// @Description Get a course by title
// @Tags courses
// @Accept json
// @Produce json
// @Param title path string true "Course title"
// @Success 200 {array} model.Course
// @Router /courses/title/{title} [get]
func (c *CourseController) GetCourseByTitle(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course by title")
        title := ctx.Param("title")
        course, err := c.service.GetCourseByTitle(title)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course by title", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course retrieved", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Update a course
// @Description Update a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param course body schemas.UpdateCourseRequest true "Course to update"
// @Success 200 {object} model.Course
// @Router /courses/{id} [put]
func (c *CourseController) UpdateCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating course")
        id := ctx.Param("id")

        var updateCourseRequest schemas.UpdateCourseRequest
        if err := ctx.ShouldBindJSON(&amp;updateCourseRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">updatedCourse, err := c.service.UpdateCourse(id, updateCourseRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Course updated", "course", updatedCourse)
        ctx.JSON(http.StatusOK, updatedCourse)</span>
}

// @Summary Get courses by student ID
// @Description Get courses by student ID
// @Tags courses
// @Accept json
// @Produce json
// @Param studentId path string true "Student ID"
// @Success 200 {array} model.Course
// @Router /courses/student/{studentId} [get]
func (c *CourseController) GetCoursesByStudentId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting courses by student ID")
        studentId := ctx.Param("studentId")
        courses, err := c.service.GetCoursesByStudentId(studentId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting courses by student ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Get courses by user ID
// @Description Get courses by user ID
// @Tags courses
// @Accept json
// @Produce json
// @Param userId path string true "User ID"
// @Success 200 {array} model.Course
// @Router /courses/user/{userId} [get]
func (c *CourseController) GetCoursesByUserId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting courses by user ID")
        userId := ctx.Param("userId")
        courses, err := c.service.GetCoursesByUserId(userId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting courses by user ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Add an aux teacher to a course
// @Description Add an aux teacher to a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
func (c *CourseController) AddAuxTeacherToCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Adding aux teacher to course")
        id := ctx.Param("id")
        if id == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var auxTeacherRequest schemas.AddAuxTeacherToCourseRequest
        if err := ctx.ShouldBindJSON(&amp;auxTeacherRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">teacherId := auxTeacherRequest.TeacherID
        auxTeacherId := auxTeacherRequest.AuxTeacherID
        course, err := c.service.AddAuxTeacherToCourse(id, teacherId, auxTeacherId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error adding aux teacher to course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Aux teacher added to course", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Remove an aux teacher from a course
// @Description Remove an aux teacher from a course by ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param removeAuxTeacherRequest body schemas.RemoveAuxTeacherFromCourseRequest true "Remove aux teacher from course request"
// @Success 200 {object} model.Course
// @Router /courses/{id}/remove-aux-teacher [delete]
func (c *CourseController) RemoveAuxTeacherFromCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Removing aux teacher from course")
        id := ctx.Param("id")
        if id == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var removeAuxTeacherRequest schemas.RemoveAuxTeacherFromCourseRequest
        if err := ctx.ShouldBindJSON(&amp;removeAuxTeacherRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">teacherId := removeAuxTeacherRequest.TeacherID
        auxTeacherId := removeAuxTeacherRequest.AuxTeacherID
        course, err := c.service.RemoveAuxTeacherFromCourse(id, teacherId, auxTeacherId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error removing aux teacher from course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Aux teacher removed from course", "course", course)
        ctx.JSON(http.StatusOK, course)</span>
}

// @Summary Get favourite courses
// @Description Get favourite courses by student ID
// @Tags courses
// @Accept json
// @Produce json
// @Param studentId path string true "Student ID"
// @Success 200 {array} model.Course
// @Router /courses/favourite/{studentId} [get]
func (c *CourseController) GetFavouriteCourses(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting favourite courses")
        studentId := ctx.Param("studentId")
        if studentId == "" </span><span class="cov8" title="1">{
                slog.Error("Student ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Student ID is required"})
                return
        }</span>

        <span class="cov8" title="1">courses, err := c.service.GetFavouriteCourses(studentId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting favourite courses", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">slog.Debug("Favourite courses retrieved", "courses", courses)
        ctx.JSON(http.StatusOK, courses)</span>
}

// @Summary Create course feedback
// @Description Create course feedback by course ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param feedback body schemas.CreateCourseFeedbackRequest true "Course feedback"
// @Success 200 {object} model.CourseFeedback
// @Router /courses/{id}/feedback [post]
func (c *CourseController) CreateCourseFeedback(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating course feedback")
        courseId := ctx.Param("id")
        if courseId == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var feedback schemas.CreateCourseFeedbackRequest
        if err := ctx.ShouldBindJSON(&amp;feedback); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding create course feedback request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if !slices.Contains(model.FeedbackTypes, feedback.FeedbackType) </span><span class="cov8" title="1">{
                slog.Error("Invalid feedback type")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid feedback type"})
                return
        }</span>

        <span class="cov8" title="1">feedbackModel, err := c.service.CreateCourseFeedback(courseId, feedback)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating course feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Course feedback created", "feedback", feedbackModel)
        ctx.JSON(http.StatusOK, feedbackModel)</span>
}

// @Summary Get course feedback
// @Description Get course feedback by course ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param getCourseFeedbackRequest body schemas.GetCourseFeedbackRequest true "Get course feedback request"
// @Success 200 {array} model.CourseFeedback
// @Router /courses/{id}/feedback [get]
func (c *CourseController) GetCourseFeedback(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course feedback")
        courseId := ctx.Param("id")
        if courseId == "" </span><span class="cov8" title="1">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">var getCourseFeedbackRequest schemas.GetCourseFeedbackRequest
        if err := ctx.ShouldBindJSON(&amp;getCourseFeedbackRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding get course feedback request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">feedback, err := c.service.GetCourseFeedback(courseId, getCourseFeedbackRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Course feedback retrieved", "feedback", feedback)
        ctx.JSON(http.StatusOK, feedback)</span>
}

// @Summary Get course feedback summary
// @Description Get course feedback summary by course ID
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {string} string "Course feedback summary"
// @Router /courses/{id}/feedback/summary [get]
func (c *CourseController) GetCourseFeedbackSummary(ctx *gin.Context) <span class="cov0" title="0">{
        slog.Debug("Getting course feedback summary")
        courseId := ctx.Param("id")
        if courseId == "" </span><span class="cov0" title="0">{
                slog.Error("Course ID is required")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Course ID is required"})
                return
        }</span>

        <span class="cov0" title="0">feedbacks, err := c.service.GetCourseFeedback(courseId, schemas.GetCourseFeedbackRequest{})
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error getting course feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if len(feedbacks) == 0 </span><span class="cov0" title="0">{
                slog.Error("No feedbacks found")
                ctx.JSON(http.StatusNotFound, gin.H{"error": "No feedbacks found"})
                return
        }</span>

        <span class="cov0" title="0">summary, err := c.aiClient.SummarizeCourseFeedbacks(feedbacks)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error getting course feedback summary", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">slog.Debug("Course feedback summary retrieved", "summary", summary)
        ctx.JSON(http.StatusOK, summary)</span>
}

// @Summary Get course members
// @Description Get all members of a course (teacher, aux teachers, and students)
// @Tags courses
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {object} schemas.CourseMembersResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /courses/{id}/members [get]
func (c *CourseController) GetCourseMembers(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting course members")

        courseId := ctx.Param("id")
        if courseId == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: "Course ID is required"})
                return
        }</span>

        <span class="cov8" title="1">members, err := c.service.GetCourseMembers(courseId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting course members", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Course members retrieved", "course_id", courseId)
        ctx.JSON(http.StatusOK, members)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "courses-service/src/ai"
        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"
        "log/slog"
        "net/http"
        "slices"

        "github.com/gin-gonic/gin"
)

type EnrollmentController struct {
        enrollmentService service.EnrollmentServiceInterface
        aiClient          *ai.AiClient
}

func NewEnrollmentController(enrollmentService service.EnrollmentServiceInterface, aiClient *ai.AiClient) *EnrollmentController <span class="cov8" title="1">{
        return &amp;EnrollmentController{enrollmentService: enrollmentService, aiClient: aiClient}
}</span>

// @Summary Enroll a student in a course
// @Description Enroll a student in a course
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param enrollmentRequest body schemas.EnrollStudentRequest true "Enrollment request"
// @Router /courses/{id}/enroll [post]
func (c *EnrollmentController) EnrollStudent(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Enrolling student", "studentId", ctx.Param("studentId"), "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID", "courseId", courseID)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var enrollmentRequest schemas.EnrollStudentRequest
        if err := ctx.ShouldBindJSON(&amp;enrollmentRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding enrollment request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.EnrollStudent(enrollmentRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error enrolling student", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Student enrolled in course", "studentId", enrollmentRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusCreated, gin.H{"message": "Student successfully enrolled in course"})</span>
}

// @Summary Unenroll a student from a course
// @Description Unenroll a student from a course
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param unenrollmentRequest body schemas.UnenrollStudentRequest true "Unenrollment request"
// @Success 200 {object} schemas.UnenrollStudentResponse
// @Router /courses/{id}/unenroll [delete]
func (c *EnrollmentController) UnenrollStudent(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Unenrolling student", "studentId", ctx.Param("studentId"), "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid student ID or course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid student ID or course ID"})
                return
        }</span>

        <span class="cov8" title="1">var unenrollmentRequest schemas.UnenrollStudentRequest
        if err := ctx.ShouldBindJSON(&amp;unenrollmentRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding unenrollment request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.UnenrollStudent(unenrollmentRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error unenrolling student", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Student unenrolled from course", "studentId", unenrollmentRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Student successfully unenrolled from course"})</span>
}

// @Summary Get enrollments by course ID
// @Description Get enrollments by course ID
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Success 200 {array} model.Enrollment
// @Router /courses/{id}/enrollments [get]
func (c *EnrollmentController) GetEnrollmentsByCourseId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting enrollments by course ID", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        enrollments, err := c.enrollmentService.GetEnrollmentsByCourseId(courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting enrollments by course ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, enrollments)</span>
}

// @Summary Set a course as favourite
// @Description Set a course as favourite
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param favouriteCourseRequest body schemas.SetFavouriteCourseRequest true "Favourite course request"
// @Success 200 {object} schemas.SetFavouriteCourseResponse
// @Router /courses/{id}/favourite [post]
func (c *EnrollmentController) SetFavouriteCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Setting favourite course", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var favouriteCourseRequest schemas.SetFavouriteCourseRequest
        if err := ctx.ShouldBindJSON(&amp;favouriteCourseRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding favourite course request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.SetFavouriteCourse(favouriteCourseRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error setting favourite course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Favourite course set", "studentId", favouriteCourseRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Favourite course set"})</span>
}

// @Summary Unset a course as favourite
// @Description Unset a course as favourite
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param unsetFavouriteCourseRequest body schemas.UnsetFavouriteCourseRequest true "Unset favourite course request"
// @Success 200 {object} schemas.UnsetFavouriteCourseResponse
// @Router /courses/{id}/favourite [delete]
func (c *EnrollmentController) UnsetFavouriteCourse(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Unsetting favourite course", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var unsetFavouriteCourseRequest schemas.UnsetFavouriteCourseRequest
        if err := ctx.ShouldBindJSON(&amp;unsetFavouriteCourseRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding unset favourite course request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.UnsetFavouriteCourse(unsetFavouriteCourseRequest.StudentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error unsetting favourite course", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Favourite course unset", "studentId", unsetFavouriteCourseRequest.StudentID, "courseId", courseID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Favourite course unset"})</span>
}

// @Summary Create a feedback for a course
// @Description Create a feedback for a course
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Course ID"
// @Param feedbackRequest body schemas.CreateStudentFeedbackRequest true "Feedback request"
// @Success 200 {object} model.StudentFeedback
// @Router /courses/{id}/student-feedback [post]
func (c *EnrollmentController) CreateFeedback(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating feedback", "courseId", ctx.Param("id"))
        courseID := ctx.Param("id")

        if courseID == "" </span><span class="cov8" title="1">{
                slog.Error("Invalid course ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
                return
        }</span>

        <span class="cov8" title="1">var feedbackRequest schemas.CreateStudentFeedbackRequest
        if err := ctx.ShouldBindJSON(&amp;feedbackRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding feedback request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if !slices.Contains(model.FeedbackTypes, feedbackRequest.FeedbackType) </span><span class="cov8" title="1">{
                slog.Error("Invalid feedback type")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid feedback type"})
                return
        }</span>

        <span class="cov8" title="1">err := c.enrollmentService.CreateStudentFeedback(feedbackRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Feedback created", "studentId", feedbackRequest.StudentUUID, "teacherId", feedbackRequest.TeacherUUID)
        ctx.JSON(http.StatusOK, gin.H{"message": "Feedback created"})</span>
}

// @Summary Get feedback by student ID
// @Description Get feedback by student ID
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Student ID"
// @Param getFeedbackByStudentIdRequest body schemas.GetFeedbackByStudentIdRequest true "Get feedback by student ID request"
// @Success 200 {array} model.StudentFeedback
// @Router /feedback/student/{id} [get]
func (c *EnrollmentController) GetFeedbackByStudentId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting feedback by student ID", "studentId", ctx.Param("id"))
        studentID := ctx.Param("id")

        if studentID == "" </span><span class="cov0" title="0">{
                slog.Error("Invalid student ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid student ID"})
                return
        }</span>

        <span class="cov8" title="1">var getFeedbackByStudentIdRequest schemas.GetFeedbackByStudentIdRequest
        if err := ctx.ShouldBindJSON(&amp;getFeedbackByStudentIdRequest); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding get feedback by student ID request", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">feedback, err := c.enrollmentService.GetFeedbackByStudentId(studentID, getFeedbackByStudentIdRequest)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting feedback by student ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Feedback retrieved", "studentId", studentID)
        ctx.JSON(http.StatusOK, feedback)</span>
}

// @Summary Get student feedback summary
// @Description Get student feedback summary by student ID
// @Tags enrollments
// @Accept json
// @Produce json
// @Param id path string true "Student ID"
// @Success 200 {string} string "Student feedback summary"
// @Router /feedback/student/{id}/summary [get]
func (c *EnrollmentController) GetStudentFeedbackSummary(ctx *gin.Context) <span class="cov0" title="0">{
        slog.Debug("Getting student feedback summary", "studentId", ctx.Param("id"))
        studentID := ctx.Param("id")

        if studentID == "" </span><span class="cov0" title="0">{
                slog.Error("Invalid student ID")
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid student ID"})
                return
        }</span>

        <span class="cov0" title="0">feedbacks, err := c.enrollmentService.GetFeedbackByStudentId(studentID, schemas.GetFeedbackByStudentIdRequest{})
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error getting student feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if len(feedbacks) == 0 </span><span class="cov0" title="0">{
                slog.Error("No feedbacks found")
                ctx.JSON(http.StatusNotFound, gin.H{"error": "No feedbacks found"})
                return
        }</span>

        <span class="cov0" title="0">summary, err := c.aiClient.SummarizeStudentFeedbacks(feedbacks)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error summarizing student feedback", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">slog.Debug("Student feedback summary retrieved", "summary", summary)
        ctx.JSON(http.StatusOK, summary)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "log/slog"
        "net/http"

        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"

        "github.com/gin-gonic/gin"
)

type ForumController struct {
        service service.ForumServiceInterface
}

func NewForumController(service service.ForumServiceInterface) *ForumController <span class="cov8" title="1">{
        return &amp;ForumController{service: service}
}</span>

// Question endpoints

// @Summary Create a new question
// @Description Create a new question in the forum for a specific course
// @Tags forum
// @Accept json
// @Produce json
// @Param question body schemas.CreateQuestionRequest true "Question to create"
// @Success 201 {object} schemas.QuestionDetailResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions [post]
func (c *ForumController) CreateQuestion(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating forum question")

        var request schemas.CreateQuestionRequest
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">question, err := c.service.CreateQuestion(
                request.CourseID,
                request.AuthorID,
                request.Title,
                request.Description,
                request.Tags,
        )
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating question", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := c.mapQuestionToDetailResponse(question)
        slog.Debug("Question created", "question_id", question.ID.Hex())
        ctx.JSON(http.StatusCreated, response)</span>
}

// @Summary Get question by ID
// @Description Get a specific question by its ID with all answers
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Success 200 {object} schemas.QuestionDetailResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId} [get]
func (c *ForumController) GetQuestionById(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting question by ID")

        id := ctx.Param("questionId")
        question, err := c.service.GetQuestionById(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting question by ID", "error", err)
                ctx.JSON(http.StatusNotFound, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := c.mapQuestionToDetailResponse(question)
        slog.Debug("Question retrieved", "question_id", id)
        ctx.JSON(http.StatusOK, response)</span>
}

// @Summary Get questions by course ID
// @Description Get all questions for a specific course
// @Tags forum
// @Accept json
// @Produce json
// @Param courseId path string true "Course ID"
// @Success 200 {array} schemas.QuestionResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/courses/{courseId}/questions [get]
func (c *ForumController) GetQuestionsByCourseId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting questions by course ID")

        courseID := ctx.Param("courseId")
        questions, err := c.service.GetQuestionsByCourseId(courseID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting questions by course ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">var responses []schemas.QuestionResponse
        for _, question := range questions </span><span class="cov8" title="1">{
                responses = append(responses, c.mapQuestionToResponse(&amp;question))
        }</span>

        <span class="cov8" title="1">slog.Debug("Questions retrieved", "course_id", courseID, "count", len(responses))
        ctx.JSON(http.StatusOK, responses)</span>
}

// @Summary Update a question
// @Description Update a question's title, description, or tags
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param question body schemas.UpdateQuestionRequest true "Question update data"
// @Success 200 {object} schemas.QuestionDetailResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 403 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId} [put]
func (c *ForumController) UpdateQuestion(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating question")

        id := ctx.Param("questionId")
        var request schemas.UpdateQuestionRequest
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">question, err := c.service.UpdateQuestion(id, request.Title, request.Description, request.Tags)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating question", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := c.mapQuestionToDetailResponse(question)
        slog.Debug("Question updated", "question_id", id)
        ctx.JSON(http.StatusOK, response)</span>
}

// @Summary Delete a question
// @Description Delete a question (only by the author)
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param authorId query string true "Author ID"
// @Success 200 {object} schemas.MessageResponse
// @Failure 403 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId} [delete]
func (c *ForumController) DeleteQuestion(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting question")

        id := ctx.Param("questionId")
        authorID := ctx.Query("authorId")

        if authorID == "" </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: "authorId query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.DeleteQuestion(id, authorID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error deleting question", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Question deleted", "question_id", id)
        ctx.JSON(http.StatusOK, schemas.MessageResponse{Message: "Question deleted successfully"})</span>
}

// Answer endpoints

// @Summary Add an answer to a question
// @Description Add a new answer to a specific question
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param answer body schemas.CreateAnswerRequest true "Answer to create"
// @Success 201 {object} schemas.AnswerResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/answers [post]
func (c *ForumController) AddAnswer(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Adding answer to question")

        questionID := ctx.Param("questionId")
        var request schemas.CreateAnswerRequest
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">answer, err := c.service.AddAnswer(questionID, request.AuthorID, request.Content)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error adding answer", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := c.mapAnswerToResponse(answer)
        slog.Debug("Answer added", "question_id", questionID, "answer_id", answer.ID)
        ctx.JSON(http.StatusCreated, response)</span>
}

// @Summary Update an answer
// @Description Update an answer's content (only by the author)
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param answerId path string true "Answer ID"
// @Param answer body schemas.UpdateAnswerRequest true "Answer update data"
// @Param authorId query string true "Author ID"
// @Success 200 {object} schemas.AnswerResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 403 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/answers/{answerId} [put]
func (c *ForumController) UpdateAnswer(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating answer")

        questionID := ctx.Param("questionId")
        answerID := ctx.Param("answerId")
        authorID := ctx.Query("authorId")

        if authorID == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: "authorId query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">var request schemas.UpdateAnswerRequest
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">answer, err := c.service.UpdateAnswer(questionID, answerID, authorID, request.Content)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating answer", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := c.mapAnswerToResponse(answer)
        slog.Debug("Answer updated", "question_id", questionID, "answer_id", answerID)
        ctx.JSON(http.StatusOK, response)</span>
}

// @Summary Delete an answer
// @Description Delete an answer (only by the author)
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param answerId path string true "Answer ID"
// @Param authorId query string true "Author ID"
// @Success 200 {object} schemas.MessageResponse
// @Failure 403 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/answers/{answerId} [delete]
func (c *ForumController) DeleteAnswer(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting answer")

        questionID := ctx.Param("questionId")
        answerID := ctx.Param("answerId")
        authorID := ctx.Query("authorId")

        if authorID == "" </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: "authorId query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.DeleteAnswer(questionID, answerID, authorID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error deleting answer", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Answer deleted", "question_id", questionID, "answer_id", answerID)
        ctx.JSON(http.StatusOK, schemas.MessageResponse{Message: "Answer deleted successfully"})</span>
}

// @Summary Accept an answer
// @Description Accept an answer as the solution (only by the question author)
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param answerId path string true "Answer ID"
// @Param authorId query string true "Question Author ID"
// @Success 200 {object} schemas.MessageResponse
// @Failure 403 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/answers/{answerId}/accept [post]
func (c *ForumController) AcceptAnswer(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Accepting answer")

        questionID := ctx.Param("questionId")
        answerID := ctx.Param("answerId")
        authorID := ctx.Query("authorId")

        if authorID == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: "authorId query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.AcceptAnswer(questionID, answerID, authorID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error accepting answer", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Answer accepted", "question_id", questionID, "answer_id", answerID)
        ctx.JSON(http.StatusOK, schemas.MessageResponse{Message: "Answer accepted successfully"})</span>
}

// Vote endpoints

// @Summary Vote on a question
// @Description Vote up or down on a question
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param vote body schemas.VoteRequest true "Vote data"
// @Success 200 {object} schemas.VoteResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 403 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/vote [post]
func (c *ForumController) VoteQuestion(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Voting on question")

        questionID := ctx.Param("questionId")
        var request schemas.VoteRequest
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.VoteQuestion(questionID, request.UserID, request.VoteType)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error voting on question", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">voteTypeStr := "up"
        if request.VoteType == model.VoteTypeDown </span><span class="cov0" title="0">{
                voteTypeStr = "down"
        }</span>

        <span class="cov8" title="1">slog.Debug("Vote registered", "question_id", questionID, "vote_type", voteTypeStr)
        ctx.JSON(http.StatusOK, schemas.VoteResponse{Message: "Vote registered successfully"})</span>
}

// @Summary Vote on an answer
// @Description Vote up or down on an answer
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param answerId path string true "Answer ID"
// @Param vote body schemas.VoteRequest true "Vote data"
// @Success 200 {object} schemas.VoteResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 403 {object} schemas.ErrorResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/answers/{answerId}/vote [post]
func (c *ForumController) VoteAnswer(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Voting on answer")

        questionID := ctx.Param("questionId")
        answerID := ctx.Param("answerId")
        var request schemas.VoteRequest
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.VoteAnswer(questionID, answerID, request.UserID, request.VoteType)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error voting on answer", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">voteTypeStr := "up"
        if request.VoteType == model.VoteTypeDown </span><span class="cov0" title="0">{
                voteTypeStr = "down"
        }</span>

        <span class="cov8" title="1">slog.Debug("Vote registered", "question_id", questionID, "answer_id", answerID, "vote_type", voteTypeStr)
        ctx.JSON(http.StatusOK, schemas.VoteResponse{Message: "Vote registered successfully"})</span>
}

// @Summary Remove vote from question
// @Description Remove a user's vote from a question
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param userId query string true "User ID"
// @Success 200 {object} schemas.MessageResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/vote [delete]
func (c *ForumController) RemoveVoteFromQuestion(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Removing vote from question")

        questionID := ctx.Param("questionId")
        userID := ctx.Query("userId")

        if userID == "" </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: "userId query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.RemoveVoteFromQuestion(questionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error removing vote from question", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Vote removed", "question_id", questionID, "user_id", userID)
        ctx.JSON(http.StatusOK, schemas.MessageResponse{Message: "Vote removed successfully"})</span>
}

// @Summary Remove vote from answer
// @Description Remove a user's vote from an answer
// @Tags forum
// @Accept json
// @Produce json
// @Param questionId path string true "Question ID"
// @Param answerId path string true "Answer ID"
// @Param userId query string true "User ID"
// @Success 200 {object} schemas.MessageResponse
// @Failure 404 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/questions/{questionId}/answers/{answerId}/vote [delete]
func (c *ForumController) RemoveVoteFromAnswer(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Removing vote from answer")

        questionID := ctx.Param("questionId")
        answerID := ctx.Param("answerId")
        userID := ctx.Query("userId")

        if userID == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: "userId query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">err := c.service.RemoveVoteFromAnswer(questionID, answerID, userID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error removing vote from answer", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Vote removed", "question_id", questionID, "answer_id", answerID, "user_id", userID)
        ctx.JSON(http.StatusOK, schemas.MessageResponse{Message: "Vote removed successfully"})</span>
}

// Search endpoints

// @Summary Search questions
// @Description Search questions in a course with optional filters
// @Tags forum
// @Accept json
// @Produce json
// @Param courseId path string true "Course ID"
// @Param query query string false "Search query"
// @Param tags query []string false "Filter by tags"
// @Param status query string false "Filter by status"
// @Success 200 {object} schemas.SearchQuestionsResponse
// @Failure 400 {object} schemas.ErrorResponse
// @Failure 500 {object} schemas.ErrorResponse
// @Router /forum/courses/{courseId}/search [get]
func (c *ForumController) SearchQuestions(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Searching questions")

        courseID := ctx.Param("courseId")

        var request schemas.SearchQuestionsRequest
        if err := ctx.ShouldBindQuery(&amp;request); err != nil </span><span class="cov0" title="0">{
                slog.Error("Error binding query parameters", "error", err)
                ctx.JSON(http.StatusBadRequest, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">questions, err := c.service.SearchQuestions(courseID, request.Query, request.Tags, request.Status)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error searching questions", "error", err)
                ctx.JSON(http.StatusInternalServerError, schemas.ErrorResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">var questionResponses []schemas.QuestionResponse
        for _, question := range questions </span><span class="cov8" title="1">{
                questionResponses = append(questionResponses, c.mapQuestionToResponse(&amp;question))
        }</span>

        <span class="cov8" title="1">response := schemas.SearchQuestionsResponse{
                Questions: questionResponses,
                Total:     len(questionResponses),
        }

        slog.Debug("Questions searched", "course_id", courseID, "total", response.Total)
        ctx.JSON(http.StatusOK, response)</span>
}

// Helper methods for mapping models to responses

func (c *ForumController) mapQuestionToResponse(question *model.ForumQuestion) schemas.QuestionResponse <span class="cov8" title="1">{
        voteCount := c.calculateVoteCount(question.Votes)
        answerCount := len(question.Answers)

        return schemas.QuestionResponse{
                ID:               question.ID.Hex(),
                CourseID:         question.CourseID,
                AuthorID:         question.AuthorID,
                Title:            question.Title,
                Description:      question.Description,
                Tags:             question.Tags,
                VoteCount:        voteCount,
                AnswerCount:      answerCount,
                Status:           question.Status,
                AcceptedAnswerID: question.AcceptedAnswerID,
                CreatedAt:        question.CreatedAt,
                UpdatedAt:        question.UpdatedAt,
        }
}</span>

func (c *ForumController) mapQuestionToDetailResponse(question *model.ForumQuestion) schemas.QuestionDetailResponse <span class="cov8" title="1">{
        voteCount := c.calculateVoteCount(question.Votes)

        var answers []schemas.AnswerResponse
        for _, answer := range question.Answers </span><span class="cov8" title="1">{
                answers = append(answers, c.mapAnswerToResponse(&amp;answer))
        }</span>

        <span class="cov8" title="1">return schemas.QuestionDetailResponse{
                ID:               question.ID.Hex(),
                CourseID:         question.CourseID,
                AuthorID:         question.AuthorID,
                Title:            question.Title,
                Description:      question.Description,
                Tags:             question.Tags,
                VoteCount:        voteCount,
                Answers:          answers,
                Status:           question.Status,
                AcceptedAnswerID: question.AcceptedAnswerID,
                CreatedAt:        question.CreatedAt,
                UpdatedAt:        question.UpdatedAt,
        }</span>
}

func (c *ForumController) mapAnswerToResponse(answer *model.ForumAnswer) schemas.AnswerResponse <span class="cov8" title="1">{
        voteCount := c.calculateVoteCount(answer.Votes)

        return schemas.AnswerResponse{
                ID:         answer.ID,
                AuthorID:   answer.AuthorID,
                Content:    answer.Content,
                VoteCount:  voteCount,
                IsAccepted: answer.IsAccepted,
                CreatedAt:  answer.CreatedAt,
                UpdatedAt:  answer.UpdatedAt,
        }
}</span>

func (c *ForumController) calculateVoteCount(votes []model.Vote) int <span class="cov8" title="1">{
        count := 0
        for _, vote := range votes </span><span class="cov8" title="1">{
                count += vote.VoteType
        }</span>
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"
        "log"
        "log/slog"
        "net/http"

        "github.com/gin-gonic/gin"
)

type ModuleController struct {
        service service.ModuleServiceInterface
}

func NewModuleController(service service.ModuleServiceInterface) *ModuleController <span class="cov8" title="1">{
        return &amp;ModuleController{
                service: service,
        }
}</span>

// @Summary Module creation
// @Description Create a new module
// @Tags modules
// @Accept json
// @Produce json
// @Param module body schemas.CreateModuleRequest true "Module to create"
// @Success 201 {object} model.Module
// @Router /modules [post]
func (c *ModuleController) CreateModule(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Creating module")

        var module schemas.CreateModuleRequest
        if err := ctx.ShouldBindJSON(&amp;module); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">log.Printf("module: %v\n", module)

        createdModule, err := c.service.CreateModule(module)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error creating module", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module created", "module", createdModule)
        ctx.JSON(http.StatusCreated, createdModule)</span>
}

// @Summary Get modules by course ID
// @Description Get modules by course ID
// @Tags modules
// @Accept json
// @Produce json
// @Param courseId path string true "Course ID"
// @Success 200 {array} model.Module
// @Router /modules/course/{courseId} [get]
func (c *ModuleController) GetModulesByCourseId(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting modules by course ID")
        courseId := ctx.Param("courseId")

        modules, err := c.service.GetModulesByCourseId(courseId)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting modules by course ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Modules retrieved", "modules", modules)
        ctx.JSON(http.StatusOK, modules)</span>
}

// @Summary Get a module by ID
// @Description Get a module by ID
// @Tags modules
// @Accept json
// @Produce json
// @Param id path string true "Module ID"
// @Success 200 {object} model.Module
// @Router /modules/{id} [get]
func (c *ModuleController) GetModuleById(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Getting module by ID")
        id := ctx.Param("id")

        module, err := c.service.GetModuleById(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error getting module by ID", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module retrieved", "module", module)
        ctx.JSON(http.StatusOK, module)</span>
}

// @Summary Update a module
// @Description Update a module by ID
// @Tags modules
// @Accept json
// @Produce json
// @Param id path string true "Module ID"
// @Param module body schemas.UpdateModuleRequest true "Module to update"
// @Success 200 {object} model.Module
// @Router /modules/{id} [put]
func (c *ModuleController) UpdateModule(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Updating module")
        id := ctx.Param("id")

        var module model.Module
        if err := ctx.ShouldBindJSON(&amp;module); err != nil </span><span class="cov8" title="1">{
                slog.Error("Error binding JSON", "error", err)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">updatedModule, err := c.service.UpdateModule(id, module)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error updating module", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module updated", "module", updatedModule)
        ctx.JSON(http.StatusOK, updatedModule)</span>
}

// @Summary Delete a module
// @Description Delete a module by ID
// @Tags modules
// @Accept json
// @Produce json
// @Param id path string true "Module ID"
// @Success 204 {string} string "Module deleted successfully"
// @Router /modules/{id} [delete]
func (c *ModuleController) DeleteModule(ctx *gin.Context) <span class="cov8" title="1">{
        slog.Debug("Deleting module")
        id := ctx.Param("id")

        err := c.service.DeleteModule(id)
        if err != nil </span><span class="cov8" title="1">{
                slog.Error("Error deleting module", "error", err)
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">slog.Debug("Module deleted", "id", id)
        ctx.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "courses-service/src/model"
        "courses-service/src/schemas"
        "courses-service/src/service"

        "github.com/gin-gonic/gin"
)

type SubmissionController struct {
        submissionService service.SubmissionServiceInterface
}

func NewSubmissionController(submissionService service.SubmissionServiceInterface) *SubmissionController <span class="cov8" title="1">{
        return &amp;SubmissionController{
                submissionService: submissionService,
        }
}</span>

type CreateSubmissionRequest struct {
        Answers []model.Answer `json:"answers"`
}

// @Summary Create a submission
// @Description Create a submission
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param submission body CreateSubmissionRequest true "Submission to create"
// @Success 201 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions [post]
func (c *SubmissionController) CreateSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        var req CreateSubmissionRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Get student info from context (assuming middleware sets this)
        <span class="cov8" title="1">studentUUID := ctx.GetString("student_uuid")
        studentName := ctx.GetString("student_name")

        submission, err := c.submissionService.GetOrCreateSubmission(ctx, assignmentID, studentUUID, studentName)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">submission.Answers = req.Answers
        submission.UpdatedAt = time.Now()

        if err := c.submissionService.UpdateSubmission(ctx, submission); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Get a submission by ID
// @Description Get a submission by ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id} [get]
func (c *SubmissionController) GetSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        submission, err := c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        // Validate submission belongs to the assignment
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Update a submission
// @Description Update a submission by ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Param submission body model.Submission true "Submission to update"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id} [put]
func (c *SubmissionController) UpdateSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        var submission model.Submission
        if err := ctx.ShouldBindJSON(&amp;submission); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate submission ID matches URL
        <span class="cov8" title="1">if submission.ID.Hex() != id </span><span class="cov8" title="1">{
                fmt.Printf("submission ID mismatch: %s != %s\n", submission.ID.Hex(), id)
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "submission ID mismatch"})
                return
        }</span>

        // Validate submission belongs to the assignment
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": "assignment ID mismatch"})
                return
        }</span>

        // Validate student ownership
        <span class="cov8" title="1">studentUUID := ctx.GetString("student_uuid")
        if submission.StudentUUID != studentUUID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">if err := c.submissionService.UpdateSubmission(ctx, &amp;submission); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Submit a submission
// @Description Submit a submission by ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id}/submit [post]
func (c *SubmissionController) SubmitSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        // Validate submission belongs to the assignment
        submission, err := c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        <span class="cov8" title="1">if err := c.submissionService.SubmitSubmission(ctx, id); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">submission, err = c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submission)</span>
}

// @Summary Get submissions by assignment ID
// @Description Get submissions by assignment ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Success 200 {array} model.Submission
// @Router /assignments/{assignmentId}/submissions [get]
func (c *SubmissionController) GetSubmissionsByAssignment(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")

        submissions, err := c.submissionService.GetSubmissionsByAssignment(ctx, assignmentID)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submissions)</span>
}

// @Summary Get submissions by student ID
// @Description Get submissions by student ID
// @Tags submissions
// @Accept json
// @Produce json
// @Param studentUUID path string true "Student ID"
// @Success 200 {array} model.Submission
// @Router /students/{studentUUID}/submissions [get]
func (c *SubmissionController) GetSubmissionsByStudent(ctx *gin.Context) <span class="cov8" title="1">{
        studentUUID := ctx.Param("studentUUID")

        // Validate student access
        requestingStudentUUID := ctx.GetString("student_uuid")
        if studentUUID != requestingStudentUUID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">submissions, err := c.submissionService.GetSubmissionsByStudent(ctx, studentUUID)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, submissions)</span>
}

// @Summary Grade a submission
// @Description Grade a submission by ID (for teachers)
// @Tags submissions
// @Accept json
// @Produce json
// @Param assignmentId path string true "Assignment ID"
// @Param id path string true "Submission ID"
// @Param gradeRequest body schemas.GradeSubmissionRequest true "Grade request"
// @Success 200 {object} model.Submission
// @Router /assignments/{assignmentId}/submissions/{id}/grade [put]
func (c *SubmissionController) GradeSubmission(ctx *gin.Context) <span class="cov8" title="1">{
        assignmentID := ctx.Param("assignmentId")
        id := ctx.Param("id")

        var gradeRequest schemas.GradeSubmissionRequest
        if err := ctx.ShouldBindJSON(&amp;gradeRequest); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Get teacher info from context
        <span class="cov8" title="1">teacherUUID := ctx.GetString("teacher_uuid")

        // Validate teacher permissions for this assignment
        if err := c.submissionService.ValidateTeacherPermissions(ctx, assignmentID, teacherUUID); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusForbidden, gin.H{"error": err.Error()})
                return
        }</span>

        // Validate submission belongs to the assignment
        <span class="cov8" title="1">submission, err := c.submissionService.GetSubmission(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>
        <span class="cov8" title="1">if submission.AssignmentID != assignmentID </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "submission not found"})
                return
        }</span>

        // Grade the submission
        <span class="cov8" title="1">gradedSubmission, err := c.submissionService.GradeSubmission(ctx, id, gradeRequest.Score, gradeRequest.Feedback)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gradedSubmission)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package database

import (
        "courses-service/src/config"
        "log/slog"

        "context"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

func NewMongoDBClient(config *config.Config) (*mongo.Client, error) <span class="cov8" title="1">{
        clientOptions := options.Client().ApplyURI(config.DBURI).SetAuth(options.Credential{
                Username: config.DBUsername,
                Password: config.DBPassword,
        })

        client, err := mongo.Connect(context.Background(), clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to connect to database", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">slog.Info("Connected to database")

        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "courses-service/src/config"
        "courses-service/src/router"
        "fmt"
        "log"

        _ "courses-service/src/docs"

        _ "github.com/swaggo/files"
        _ "github.com/swaggo/gin-swagger"
)

// @title Courses Service API
// @version 1.0
// @description API for managing courses and related resources

// @contact.name   El mejor grupo de todos ndea deau
// @contact.url    https://github.com/classconnect-grupo3
// @contact.email  classconnectingsoft2@gmail.com

func main() <span class="cov0" title="0">{
        config := config.NewConfig()
        r := router.NewRouter(config)
        if err := r.Run(fmt.Sprintf("%s:%s", config.Host, config.Port)); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

// StudentAuth is a middleware that extracts student information from the X-Student-UUID and X-Student-Name
// headers and sets them in the context for handlers to use.
func StudentAuth() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                studentUUID := c.GetHeader("X-Student-UUID")
                studentName := c.GetHeader("X-Student-Name")

                if studentUUID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "X-Student-UUID header is required"})
                        c.Abort()
                        return
                }</span>

                // Set values in context for downstream handlers
                <span class="cov0" title="0">c.Set("student_uuid", studentUUID)
                c.Set("student_name", studentName)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

// TeacherAuth is a middleware that extracts teacher information from the X-Teacher-UUID and X-Teacher-Name
// headers and sets them in the context for handlers to use.
func TeacherAuth() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                teacherUUID := c.GetHeader("X-Teacher-UUID")
                teacherName := c.GetHeader("X-Teacher-Name")

                if teacherUUID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "X-Teacher-UUID header is required"})
                        c.Abort()
                        return
                }</span>

                // Set values in context for downstream handlers
                <span class="cov0" title="0">c.Set("teacher_uuid", teacherUUID)
                c.Set("teacher_name", teacherName)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type AssignmentRepository struct {
        db                   *mongo.Client
        dbName               string
        assignmentCollection *mongo.Collection
}

func NewAssignmentRepository(db *mongo.Client, dbName string) AssignmentRepositoryInterface <span class="cov8" title="1">{
        return &amp;AssignmentRepository{
                db:                   db,
                dbName:               dbName,
                assignmentCollection: db.Database(dbName).Collection("assignments"),
        }
}</span>

func (r *AssignmentRepository) CreateAssignment(assignment model.Assignment) (*model.Assignment, error) <span class="cov8" title="1">{
        result, err := r.assignmentCollection.InsertOne(context.TODO(), assignment)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create assignment: %v", err)
        }</span>

        <span class="cov8" title="1">assignment.ID = result.InsertedID.(primitive.ObjectID)
        return &amp;assignment, nil</span>
}

func (r *AssignmentRepository) GetAssignments() ([]*model.Assignment, error) <span class="cov8" title="1">{
        cursor, err := r.assignmentCollection.Find(context.TODO(), bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments: %v", err)
        }</span>

        <span class="cov8" title="1">var assignments []*model.Assignment
        if err := cursor.All(context.TODO(), &amp;assignments); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments: %v", err)
        }</span>

        // Ensure we return an empty slice instead of nil when no documents are found
        <span class="cov8" title="1">if assignments == nil </span><span class="cov8" title="1">{
                assignments = []*model.Assignment{}
        }</span>

        <span class="cov8" title="1">return assignments, nil</span>
}

func (r *AssignmentRepository) GetByID(ctx context.Context, id string) (*model.Assignment, error) <span class="cov8" title="1">{
        var assignment model.Assignment
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get assignment by id: %v", err)
        }</span>

        <span class="cov8" title="1">err = r.assignmentCollection.FindOne(ctx, bson.M{"_id": objectId}).Decode(&amp;assignment)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get assignment by id: %v", err)</span>
        }

        <span class="cov8" title="1">return &amp;assignment, nil</span>
}

func (r *AssignmentRepository) GetAssignmentsByCourseId(courseId string) ([]*model.Assignment, error) <span class="cov8" title="1">{
        cursor, err := r.assignmentCollection.Find(context.TODO(), bson.M{"course_id": courseId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments by course id: %v", err)
        }</span>

        <span class="cov8" title="1">var assignments []*model.Assignment
        if err := cursor.All(context.TODO(), &amp;assignments); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments by course id: %v", err)
        }</span>

        // Ensure we return an empty slice instead of nil when no documents are found
        <span class="cov8" title="1">if assignments == nil </span><span class="cov8" title="1">{
                assignments = []*model.Assignment{}
        }</span>

        <span class="cov8" title="1">return assignments, nil</span>
}

func filterEmptyAssignmentFields(assignment model.Assignment) bson.M <span class="cov8" title="1">{
        update := bson.M{}

        if assignment.Title != "" </span><span class="cov8" title="1">{
                update["title"] = assignment.Title
        }</span>
        <span class="cov8" title="1">if assignment.Description != "" </span><span class="cov8" title="1">{
                update["description"] = assignment.Description
        }</span>
        <span class="cov8" title="1">if assignment.Type != "" </span><span class="cov8" title="1">{
                update["type"] = assignment.Type
        }</span>
        <span class="cov8" title="1">if !assignment.DueDate.IsZero() </span><span class="cov0" title="0">{
                update["due_date"] = assignment.DueDate
        }</span>
        <span class="cov8" title="1">if assignment.Status != "" </span><span class="cov8" title="1">{
                update["status"] = assignment.Status
        }</span>
        <span class="cov8" title="1">if assignment.GracePeriod &gt; 0 </span><span class="cov8" title="1">{
                update["grace_period"] = assignment.GracePeriod
        }</span>
        <span class="cov8" title="1">if len(assignment.SubmissionRules) &gt; 0 </span><span class="cov8" title="1">{
                update["submission_rules"] = assignment.SubmissionRules
        }</span>
        <span class="cov8" title="1">if assignment.Instructions != "" </span><span class="cov8" title="1">{
                update["instructions"] = assignment.Instructions
        }</span>
        <span class="cov8" title="1">if len(assignment.Questions) &gt; 0 </span><span class="cov8" title="1">{
                update["questions"] = assignment.Questions
        }</span>
        <span class="cov8" title="1">if assignment.TotalPoints &gt; 0 </span><span class="cov8" title="1">{
                update["total_points"] = assignment.TotalPoints
        }</span>
        <span class="cov8" title="1">if assignment.PassingScore &gt; 0 </span><span class="cov8" title="1">{
                update["passing_score"] = assignment.PassingScore
        }</span>
        <span class="cov8" title="1">update["updated_at"] = primitive.NewDateTimeFromTime(time.Now())

        return update</span>
}

func (r *AssignmentRepository) UpdateAssignment(id string, updateAssignment model.Assignment) (*model.Assignment, error) <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update assignment: %v", err)
        }</span>

        <span class="cov8" title="1">update := filterEmptyAssignmentFields(updateAssignment)

        _, err = r.assignmentCollection.UpdateOne(context.TODO(), bson.M{"_id": objectId}, bson.M{"$set": update})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update assignment: %v", err)
        }</span>

        <span class="cov8" title="1">updatedAssignment, err := r.GetByID(context.TODO(), id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get updated assignment: %v", err)
        }</span>

        <span class="cov8" title="1">return updatedAssignment, nil</span>
}

func (r *AssignmentRepository) DeleteAssignment(id string) error <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete assignment: %v", err)
        }</span>

        <span class="cov8" title="1">_, err = r.assignmentCollection.DeleteOne(context.TODO(), bson.M{"_id": objectId})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete assignment: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "courses-service/src/schemas"
        "errors"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"

        "reflect"
)

type CourseRepository struct {
        db                   *mongo.Client
        dbName               string
        courseCollection     *mongo.Collection
        enrollmentCollection *mongo.Collection
}

func filterEmptyFields(course model.Course) any <span class="cov8" title="1">{
        updates := bson.D{}

        courseType := reflect.TypeOf(course)
        courseValue := reflect.ValueOf(course)

        for i := 0; i &lt; courseType.NumField(); i++ </span><span class="cov8" title="1">{
                field := courseType.Field(i)
                fieldValue := courseValue.Field(i)
                tag := field.Tag.Get("json")
                if !isZeroType(fieldValue) </span><span class="cov8" title="1">{
                        update := bson.E{Key: tag, Value: fieldValue.Interface()}
                        updates = append(updates, update)
                }</span>
        }

        <span class="cov8" title="1">return updates</span>
}

func isZeroType(value reflect.Value) bool <span class="cov8" title="1">{
        zero := reflect.Zero(value.Type()).Interface()

        switch value.Kind() </span>{
        case reflect.Slice, reflect.Array, reflect.Chan, reflect.Map:<span class="cov8" title="1">
                return value.Len() == 0</span>
        case reflect.String:<span class="cov8" title="1">
                return value.String() == ""</span>
        case reflect.Int:<span class="cov8" title="1">
                return value.Int() == 0</span>
        case reflect.Bool:<span class="cov0" title="0">
                return !value.Bool()</span>
        case reflect.Float64:<span class="cov0" title="0">
                return value.Float() == 0</span>
        default:<span class="cov8" title="1">
                return reflect.DeepEqual(zero, value.Interface())</span>
        }
}

func NewCourseRepository(db *mongo.Client, dbName string) *CourseRepository <span class="cov8" title="1">{
        return &amp;CourseRepository{
                db:                   db,
                dbName:               dbName,
                courseCollection:     db.Database(dbName).Collection("courses"),
                enrollmentCollection: db.Database(dbName).Collection("enrollments"),
        }
}</span>

func (r *CourseRepository) CreateCourse(course model.Course) (*model.Course, error) <span class="cov8" title="1">{
        result, err := r.courseCollection.InsertOne(context.TODO(), course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create course: %v", err)
        }</span>

        <span class="cov8" title="1">course.ID = result.InsertedID.(primitive.ObjectID)
        return &amp;course, nil</span>
}

func (r *CourseRepository) GetCourses() ([]*model.Course, error) <span class="cov8" title="1">{
        cursor, err := r.courseCollection.Find(context.TODO(), bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get courses: %v", err)
        }</span>

        <span class="cov8" title="1">var courses []*model.Course
        if err := cursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get courses: %v", err)
        }</span>

        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) GetCourseById(id string) (*model.Course, error) <span class="cov8" title="1">{
        var course model.Course
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get course by id: %v", err)
        }</span>
        <span class="cov8" title="1">err = r.courseCollection.FindOne(context.TODO(), bson.M{"_id": objectId}).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get course by id: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;course, nil</span>
}

func (r *CourseRepository) GetCourseByTeacherId(teacherId string) ([]*model.Course, error) <span class="cov8" title="1">{
        cursor, err := r.courseCollection.Find(context.TODO(), bson.M{"teacher_uuid": teacherId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by teacher id: %v", err)
        }</span>

        <span class="cov8" title="1">var courses []*model.Course
        if err := cursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by teacher id: %v", err)
        }</span>
        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) GetCoursesByStudentId(studentId string) ([]*model.Course, error) <span class="cov8" title="1">{
        // First, get all enrollment records for this student
        cursor, err := r.enrollmentCollection.Find(context.TODO(), bson.M{"student_id": studentId})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get enrollments by student id: %v", err)
        }</span>

        // Parse enrollments to get course IDs
        <span class="cov8" title="1">var enrollments []model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse enrollments: %v", err)
        }</span>

        <span class="cov8" title="1">if len(enrollments) == 0 </span><span class="cov8" title="1">{
                return []*model.Course{}, nil
        }</span>

        // Extract course IDs from enrollments
        <span class="cov8" title="1">var courseIds []primitive.ObjectID
        for _, enrollment := range enrollments </span><span class="cov8" title="1">{
                courseId, err := primitive.ObjectIDFromHex(enrollment.CourseID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid course id in enrollment: %v", err)
                }</span>
                <span class="cov8" title="1">courseIds = append(courseIds, courseId)</span>
        }

        // Find all courses with these IDs
        <span class="cov8" title="1">filter := bson.M{"_id": bson.M{"$in": courseIds}}
        courseCursor, err := r.courseCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get courses by ids: %v", err)
        }</span>

        // Parse courses
        <span class="cov8" title="1">var courses []*model.Course
        if err := courseCursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse courses: %v", err)
        }</span>

        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) GetCourseByTitle(title string) ([]*model.Course, error) <span class="cov8" title="1">{
        filter := bson.M{
                "title": bson.M{
                        "$regex":   title,
                        "$options": "i",
                },
        }

        var courses []*model.Course
        cursor, err := r.courseCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by title: %v", err)
        }</span>

        <span class="cov8" title="1">if err := cursor.All(context.TODO(), &amp;courses); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get course by title: %v", err)
        }</span>

        <span class="cov8" title="1">return courses, nil</span>
}

func (r *CourseRepository) DeleteCourse(id string) error <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete course: %v", err)
        }</span>
        <span class="cov8" title="1">_, err = r.courseCollection.DeleteOne(context.TODO(), bson.M{"_id": objectId})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete course: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *CourseRepository) UpdateCourse(id string, updateCourseRequest model.Course) (*model.Course, error) <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update course: %v", err)
        }</span>

        <span class="cov8" title="1">update := filterEmptyFields(updateCourseRequest)

        _, err = r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": objectId}, bson.M{"$set": update})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update course: %v", err)
        }</span>

        <span class="cov8" title="1">updatedCourse, err := r.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update course: %v", err)
        }</span>

        <span class="cov8" title="1">return updatedCourse, nil</span>
}

func (r *CourseRepository) AddAuxTeacherToCourse(course *model.Course, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        course.AuxTeachers = append(course.AuxTeachers, auxTeacherId)
        course.UpdatedAt = time.Now()

        // Direct MongoDB update to ensure we can set the exact AuxTeachers array
        update := bson.M{
                "$set": bson.M{
                        "aux_teachers": course.AuxTeachers,
                        "updated_at":   course.UpdatedAt,
                },
        }

        _, err := r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": course.ID}, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add aux teacher to course: %v", err)
        }</span>

        <span class="cov8" title="1">return r.GetCourseById(course.ID.Hex())</span>
}

func (r *CourseRepository) RemoveAuxTeacherFromCourse(course *model.Course, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        // Buscar y eliminar el auxTeacherId del slice
        for i, teacher := range course.AuxTeachers </span><span class="cov8" title="1">{
                if teacher == auxTeacherId </span><span class="cov8" title="1">{
                        // Eliminar el elemento del slice
                        course.AuxTeachers = append(course.AuxTeachers[:i], course.AuxTeachers[i+1:]...)
                        break</span>
                }
        }

        <span class="cov8" title="1">course.UpdatedAt = time.Now()

        // Direct MongoDB update to ensure we can set empty arrays
        update := bson.M{
                "$set": bson.M{
                        "aux_teachers": course.AuxTeachers,
                        "updated_at":   course.UpdatedAt,
                },
        }

        _, err := r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": course.ID}, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to remove aux teacher from course: %v", err)
        }</span>

        <span class="cov8" title="1">return r.GetCourseById(course.ID.Hex())</span>
}

func (r *CourseRepository) UpdateStudentsAmount(courseID string, newStudentsAmount int) error <span class="cov8" title="1">{
        objectId, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update students amount: %v", err)
        }</span>

        // Direct MongoDB update to ensure we can set StudentsAmount to 0
        <span class="cov8" title="1">update := bson.M{
                "$set": bson.M{
                        "students_amount": newStudentsAmount,
                        "updated_at":      time.Now(),
                },
        }

        _, err = r.courseCollection.UpdateOne(context.TODO(), bson.M{"_id": objectId}, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update students amount: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *CourseRepository) CreateCourseFeedback(courseID string, feedback model.CourseFeedback) (*model.CourseFeedback, error) <span class="cov8" title="1">{
        feedback.ID = primitive.NewObjectID()

        course, err := r.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if course.Feedback == nil </span><span class="cov0" title="0">{
                course.Feedback = []model.CourseFeedback{}
        }</span>

        <span class="cov8" title="1">course.Feedback = append(course.Feedback, feedback)

        _, err = r.UpdateCourse(course.ID.Hex(), *course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;feedback, nil</span>
}

func (r *CourseRepository) matchesFeedbackFilters(feedback *model.CourseFeedback, request schemas.GetCourseFeedbackRequest) bool <span class="cov8" title="1">{
        // Filter by feedback type
        if request.FeedbackType != "" &amp;&amp; feedback.FeedbackType != request.FeedbackType </span><span class="cov8" title="1">{
                return false
        }</span>

        // Filter by score range
        <span class="cov8" title="1">if request.StartScore != 0 &amp;&amp; feedback.Score &lt; request.StartScore </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if request.EndScore != 0 &amp;&amp; feedback.Score &gt; request.EndScore </span><span class="cov0" title="0">{
                return false
        }</span>

        // Filter by date range
        <span class="cov8" title="1">if !request.StartDate.IsZero() &amp;&amp; feedback.CreatedAt.Before(request.StartDate) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !request.EndDate.IsZero() &amp;&amp; feedback.CreatedAt.After(request.EndDate) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (r *CourseRepository) GetCourseFeedback(courseID string, getCourseFeedbackRequest schemas.GetCourseFeedbackRequest) ([]*model.CourseFeedback, error) <span class="cov8" title="1">{
        // Convert courseID to ObjectID
        objectId, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid course ID format: " + err.Error())
        }</span>

        // Get the course document
        <span class="cov8" title="1">var course model.Course
        err = r.courseCollection.FindOne(context.TODO(), bson.M{"_id": objectId}).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, errors.New("course not found")
                }</span>
                <span class="cov0" title="0">return nil, errors.New("error getting course: " + err.Error())</span>
        }

        // If course has no feedback, return empty slice
        <span class="cov8" title="1">if len(course.Feedback) == 0 </span><span class="cov8" title="1">{
                return []*model.CourseFeedback{}, nil
        }</span>

        // Apply filters to the feedback
        <span class="cov8" title="1">filteredFeedbacks := []*model.CourseFeedback{}
        for _, feedback := range course.Feedback </span><span class="cov8" title="1">{
                if r.matchesFeedbackFilters(&amp;feedback, getCourseFeedbackRequest) </span><span class="cov8" title="1">{
                        // Create a copy to avoid pointer issues
                        feedbackCopy := feedback
                        filteredFeedbacks = append(filteredFeedbacks, &amp;feedbackCopy)
                }</span>
        }

        <span class="cov8" title="1">return filteredFeedbacks, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "courses-service/src/schemas"
        "fmt"
        "log/slog"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type EnrollmentRepository struct {
        db                   *mongo.Client
        dbName               string
        enrollmentCollection *mongo.Collection
        courseRepository     *CourseRepository
}

func NewEnrollmentRepository(db *mongo.Client, dbName string, courseRepository *CourseRepository) *EnrollmentRepository <span class="cov8" title="1">{
        return &amp;EnrollmentRepository{db: db, dbName: dbName, enrollmentCollection: db.Database(dbName).Collection("enrollments"), courseRepository: courseRepository}
}</span>

func (r *EnrollmentRepository) createEnrollmentAndModifyCourseCapacity(enrollment model.Enrollment, course *model.Course, ctx context.Context) (interface{}, error) <span class="cov8" title="1">{
        res, err := r.enrollmentCollection.InsertOne(ctx, enrollment)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error creating enrollment", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">enrollment.ID = res.InsertedID.(primitive.ObjectID)

        err = r.courseRepository.UpdateStudentsAmount(course.ID.Hex(), course.StudentsAmount+1)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error updating course capacity", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return enrollment, nil</span>
}

func (r *EnrollmentRepository) CreateEnrollment(enrollment model.Enrollment, course *model.Course) error <span class="cov8" title="1">{
        _, err := r.createEnrollmentAndModifyCourseCapacity(enrollment, course, context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) GetEnrollmentsByCourseId(courseID string) ([]*model.Enrollment, error) <span class="cov8" title="1">{
        filter := bson.M{
                "course_id": courseID,
        }

        cursor, err := r.enrollmentCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var enrollments []*model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure we always return a non-nil slice
        <span class="cov8" title="1">if enrollments == nil </span><span class="cov8" title="1">{
                enrollments = []*model.Enrollment{}
        }</span>

        <span class="cov8" title="1">return enrollments, nil</span>
}

func (r *EnrollmentRepository) IsEnrolled(studentID, courseID string) (bool, error) <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        var enrollment model.Enrollment
        err := r.enrollmentCollection.FindOne(context.TODO(), filter).Decode(&amp;enrollment)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

func (r *EnrollmentRepository) deleteEnrollmentAndModifyCourseCapacity(studentID string, course *model.Course, ctx context.Context) error <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  course.ID.Hex(),
        }

        result, err := r.enrollmentCollection.DeleteOne(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Only update course capacity if we actually deleted an enrollment
        <span class="cov8" title="1">if result.DeletedCount &gt; 0 </span><span class="cov8" title="1">{
                err = r.courseRepository.UpdateStudentsAmount(course.ID.Hex(), course.StudentsAmount-1)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) DeleteEnrollment(studentID string, course *model.Course) error <span class="cov8" title="1">{
        err := r.deleteEnrollmentAndModifyCourseCapacity(studentID, course, context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) SetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        update := bson.M{
                "$set": bson.M{
                        "favourite": true,
                },
        }

        res, err := r.enrollmentCollection.UpdateOne(context.TODO(), filter, update)
        if res.MatchedCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("enrollment not found for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error setting favourite course for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) UnsetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        update := bson.M{
                "$set": bson.M{
                        "favourite": false,
                },
        }

        res, err := r.enrollmentCollection.UpdateOne(context.TODO(), filter, update)
        if res.MatchedCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("enrollment not found for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unsetting favourite course for student %s in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) GetEnrollmentByStudentIdAndCourseId(studentID, courseID string) (*model.Enrollment, error) <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
                "course_id":  courseID,
        }

        var enrollment model.Enrollment
        err := r.enrollmentCollection.FindOne(context.TODO(), filter).Decode(&amp;enrollment)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;enrollment, nil</span>
}

func (r *EnrollmentRepository) GetEnrollmentsByStudentId(studentID string) ([]*model.Enrollment, error) <span class="cov8" title="1">{
        filter := bson.M{
                "student_id": studentID,
        }

        cursor, err := r.enrollmentCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return []*model.Enrollment{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var enrollments []*model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return enrollments, nil</span>
}

func (r *EnrollmentRepository) CreateStudentFeedback(feedbackRequest model.StudentFeedback, enrollmentID string) error <span class="cov8" title="1">{
        feedbackRequest.ID = primitive.NewObjectID()

        // Convert string ID to ObjectID
        objID, err := primitive.ObjectIDFromHex(enrollmentID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid enrollment ID: %v", err)
        }</span>

        <span class="cov8" title="1">_, err = r.enrollmentCollection.UpdateOne(context.TODO(), bson.M{"_id": objID}, bson.M{"$push": bson.M{"feedback": feedbackRequest}})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *EnrollmentRepository) matchesFeedbackFilters(feedback *model.StudentFeedback, request schemas.GetFeedbackByStudentIdRequest) bool <span class="cov8" title="1">{
        // Filter by feedback type
        if request.FeedbackType != "" &amp;&amp; feedback.FeedbackType != request.FeedbackType </span><span class="cov8" title="1">{
                return false
        }</span>

        // Filter by score range
        <span class="cov8" title="1">if request.StartScore != 0 &amp;&amp; feedback.Score &lt; request.StartScore </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if request.EndScore != 0 &amp;&amp; feedback.Score &gt; request.EndScore </span><span class="cov0" title="0">{
                return false
        }</span>

        // Filter by date range
        <span class="cov8" title="1">if !request.StartDate.IsZero() &amp;&amp; feedback.CreatedAt.Before(request.StartDate) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !request.EndDate.IsZero() &amp;&amp; feedback.CreatedAt.After(request.EndDate) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (r *EnrollmentRepository) GetFeedbackByStudentId(studentID string, getFeedbackByStudentIdRequest schemas.GetFeedbackByStudentIdRequest) ([]*model.StudentFeedback, error) <span class="cov8" title="1">{
        // Build base filter for enrollments of the student
        filter := bson.M{
                "student_id": studentID,
                "feedback":   bson.M{"$exists": true, "$ne": []interface{}{}}, // Must have non-empty feedback array
        }

        // Add course filter if specified
        if getFeedbackByStudentIdRequest.CourseID != "" </span><span class="cov8" title="1">{
                filter["course_id"] = getFeedbackByStudentIdRequest.CourseID
        }</span>

        // Find all enrollments for this student
        <span class="cov8" title="1">cursor, err := r.enrollmentCollection.Find(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return []*model.StudentFeedback{}, nil // Return empty slice on error instead of nil
        }</span>
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var enrollments []*model.Enrollment
        if err := cursor.All(context.TODO(), &amp;enrollments); err != nil </span><span class="cov0" title="0">{
                return []*model.StudentFeedback{}, nil // Return empty slice on error instead of nil
        }</span>

        // Extract and filter feedbacks from enrollments
        <span class="cov8" title="1">var allFeedbacks []*model.StudentFeedback
        for _, enrollment := range enrollments </span><span class="cov8" title="1">{
                for _, feedback := range enrollment.Feedback </span><span class="cov8" title="1">{
                        // Apply feedback filters
                        if r.matchesFeedbackFilters(&amp;feedback, getFeedbackByStudentIdRequest) </span><span class="cov8" title="1">{
                                // Create a copy to avoid pointer issues
                                feedbackCopy := feedback
                                allFeedbacks = append(allFeedbacks, &amp;feedbackCopy)
                        }</span>
                }
        }

        // Ensure we always return a non-nil slice
        <span class="cov8" title="1">if allFeedbacks == nil </span><span class="cov8" title="1">{
                allFeedbacks = []*model.StudentFeedback{}
        }</span>

        <span class="cov8" title="1">return allFeedbacks, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type ForumRepository struct {
        db                 *mongo.Client
        dbName             string
        questionCollection *mongo.Collection
}

func NewForumRepository(db *mongo.Client, dbName string) *ForumRepository <span class="cov8" title="1">{
        return &amp;ForumRepository{
                db:                 db,
                dbName:             dbName,
                questionCollection: db.Database(dbName).Collection("forum_questions"),
        }
}</span>

// Question operations

func (r *ForumRepository) CreateQuestion(question model.ForumQuestion) (*model.ForumQuestion, error) <span class="cov8" title="1">{
        question.ID = primitive.NewObjectID()
        question.CreatedAt = time.Now()
        question.UpdatedAt = time.Now()
        question.Status = model.QuestionStatusOpen
        question.Votes = []model.Vote{}
        question.Answers = []model.ForumAnswer{}

        _, err := r.questionCollection.InsertOne(context.TODO(), question)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create question: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;question, nil</span>
}

func (r *ForumRepository) GetQuestionById(id string) (*model.ForumQuestion, error) <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid question ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": questionUUID}
        var question model.ForumQuestion
        err = r.questionCollection.FindOne(context.TODO(), filter).Decode(&amp;question)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("question with id %s not found", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to find question: %v", err)</span>
        }

        <span class="cov8" title="1">return &amp;question, nil</span>
}

func (r *ForumRepository) GetQuestionsByCourseId(courseID string) ([]model.ForumQuestion, error) <span class="cov8" title="1">{
        filter := bson.M{"course_id": courseID}

        // Sort by created_at descending (newest first)
        opts := options.Find().SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.questionCollection.Find(context.TODO(), filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find questions: %v", err)
        }</span>
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var questions []model.ForumQuestion
        if err = cursor.All(context.TODO(), &amp;questions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode questions: %v", err)
        }</span>

        <span class="cov8" title="1">return questions, nil</span>
}

func (r *ForumRepository) UpdateQuestion(id string, question model.ForumQuestion) (*model.ForumQuestion, error) <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid question ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": questionUUID}
        updateFields := bson.M{}

        if question.Title != "" </span><span class="cov8" title="1">{
                updateFields["title"] = question.Title
        }</span>
        <span class="cov8" title="1">if question.Description != "" </span><span class="cov8" title="1">{
                updateFields["description"] = question.Description
        }</span>
        <span class="cov8" title="1">if len(question.Tags) &gt; 0 </span><span class="cov8" title="1">{
                updateFields["tags"] = question.Tags
        }</span>
        <span class="cov8" title="1">if question.Status != "" </span><span class="cov8" title="1">{
                updateFields["status"] = question.Status
        }</span>

        <span class="cov8" title="1">updateFields["updated_at"] = time.Now()

        update := bson.M{"$set": updateFields}

        var updatedQuestion model.ForumQuestion
        err = r.questionCollection.FindOneAndUpdate(
                context.TODO(),
                filter,
                update,
                options.FindOneAndUpdate().SetReturnDocument(options.After),
        ).Decode(&amp;updatedQuestion)

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("question not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update question: %v", err)</span>
        }

        <span class="cov8" title="1">return &amp;updatedQuestion, nil</span>
}

func (r *ForumRepository) DeleteQuestion(id string) error <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid question ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": questionUUID}
        result, err := r.questionCollection.DeleteOne(context.TODO(), filter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete question: %v", err)
        }</span>

        <span class="cov8" title="1">if result.DeletedCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("question not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Answer operations

func (r *ForumRepository) AddAnswer(questionID string, answer model.ForumAnswer) (*model.ForumAnswer, error) <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid question ID: %v", err)
        }</span>

        // Generate a unique answer ID
        <span class="cov8" title="1">answer.ID = primitive.NewObjectID().Hex()
        answer.CreatedAt = time.Now()
        answer.UpdatedAt = time.Now()
        answer.Votes = []model.Vote{}
        answer.IsAccepted = false

        filter := bson.M{"_id": questionUUID}
        update := bson.M{
                "$push": bson.M{"answers": answer},
                "$set":  bson.M{"updated_at": time.Now()},
        }

        result, err := r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add answer: %v", err)
        }</span>

        <span class="cov8" title="1">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("question not found")
        }</span>

        <span class="cov8" title="1">return &amp;answer, nil</span>
}

func (r *ForumRepository) UpdateAnswer(questionID string, answerID string, content string) (*model.ForumAnswer, error) <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid question ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{
                "_id":        questionUUID,
                "answers.id": answerID,
        }
        update := bson.M{
                "$set": bson.M{
                        "answers.$.content":    content,
                        "answers.$.updated_at": time.Now(),
                        "updated_at":           time.Now(),
                },
        }

        result, err := r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update answer: %v", err)
        }</span>

        <span class="cov8" title="1">if result.MatchedCount == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("question or answer not found")
        }</span>

        // Get the updated question to return the answer
        <span class="cov8" title="1">question, err := r.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Find and return the updated answer
        <span class="cov8" title="1">for _, ans := range question.Answers </span><span class="cov8" title="1">{
                if ans.ID == answerID </span><span class="cov8" title="1">{
                        return &amp;ans, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("answer not found after update")</span>
}

func (r *ForumRepository) DeleteAnswer(questionID string, answerID string) error <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid question ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": questionUUID}
        update := bson.M{
                "$pull": bson.M{"answers": bson.M{"id": answerID}},
                "$set":  bson.M{"updated_at": time.Now()},
        }

        result, err := r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete answer: %v", err)
        }</span>

        <span class="cov8" title="1">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("question not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ForumRepository) AcceptAnswer(questionID string, answerID string) error <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid question ID: %v", err)
        }</span>

        // First, unmark any previously accepted answer
        <span class="cov8" title="1">filter := bson.M{"_id": questionUUID}
        update := bson.M{
                "$set": bson.M{
                        "answers.$[].is_accepted": false,
                        "updated_at":              time.Now(),
                },
        }

        _, err = r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmark previous accepted answers: %v", err)
        }</span>

        // Now mark the specific answer as accepted and update question status
        <span class="cov8" title="1">filter = bson.M{
                "_id":        questionUUID,
                "answers.id": answerID,
        }
        update = bson.M{
                "$set": bson.M{
                        "answers.$.is_accepted": true,
                        "accepted_answer_id":    answerID,
                        "status":                model.QuestionStatusResolved,
                        "updated_at":            time.Now(),
                },
        }

        result, err := r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to accept answer: %v", err)
        }</span>

        <span class="cov8" title="1">if result.MatchedCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("question or answer not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Vote operations

func (r *ForumRepository) AddVoteToQuestion(questionID string, userID string, voteType int) error <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid question ID: %v", err)
        }</span>

        // First, remove any existing vote from this user
        <span class="cov8" title="1">err = r.RemoveVoteFromQuestion(questionID, userID)
        if err != nil </span>{<span class="cov0" title="0">
                // Ignore error if no vote exists
        }</span>

        // Add the new vote
        <span class="cov8" title="1">vote := model.Vote{
                UserID:    userID,
                VoteType:  voteType,
                CreatedAt: time.Now(),
        }

        filter := bson.M{"_id": questionUUID}
        update := bson.M{
                "$push": bson.M{"votes": vote},
                "$set":  bson.M{"updated_at": time.Now()},
        }

        result, err := r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add vote: %v", err)
        }</span>

        <span class="cov8" title="1">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("question not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ForumRepository) AddVoteToAnswer(questionID string, answerID string, userID string, voteType int) error <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid question ID: %v", err)
        }</span>

        // First, remove any existing vote from this user on this answer
        <span class="cov8" title="1">err = r.RemoveVoteFromAnswer(questionID, answerID, userID)
        if err != nil </span>{<span class="cov0" title="0">
                // Ignore error if no vote exists
        }</span>

        // Add the new vote
        <span class="cov8" title="1">vote := model.Vote{
                UserID:    userID,
                VoteType:  voteType,
                CreatedAt: time.Now(),
        }

        filter := bson.M{
                "_id":        questionUUID,
                "answers.id": answerID,
        }
        update := bson.M{
                "$push": bson.M{"answers.$.votes": vote},
                "$set":  bson.M{"updated_at": time.Now()},
        }

        result, err := r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add vote to answer: %v", err)
        }</span>

        <span class="cov8" title="1">if result.MatchedCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("question or answer not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ForumRepository) RemoveVoteFromQuestion(questionID string, userID string) error <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid question ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": questionUUID}
        update := bson.M{
                "$pull": bson.M{"votes": bson.M{"user_id": userID}},
                "$set":  bson.M{"updated_at": time.Now()},
        }

        _, err = r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove vote: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ForumRepository) RemoveVoteFromAnswer(questionID string, answerID string, userID string) error <span class="cov8" title="1">{
        questionUUID, err := primitive.ObjectIDFromHex(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid question ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{
                "_id":        questionUUID,
                "answers.id": answerID,
        }
        update := bson.M{
                "$pull": bson.M{"answers.$.votes": bson.M{"user_id": userID}},
                "$set":  bson.M{"updated_at": time.Now()},
        }

        _, err = r.questionCollection.UpdateOne(context.TODO(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove vote from answer: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Search and filter operations

func (r *ForumRepository) SearchQuestions(courseID string, query string, tags []model.QuestionTag, status model.QuestionStatus) ([]model.ForumQuestion, error) <span class="cov8" title="1">{
        filter := bson.M{"course_id": courseID}

        // Add text search if query is provided
        if query != "" </span><span class="cov8" title="1">{
                filter["$or"] = []bson.M{
                        {"title": bson.M{"$regex": query, "$options": "i"}},
                        {"description": bson.M{"$regex": query, "$options": "i"}},
                }
        }</span>

        // Add tags filter if provided
        <span class="cov8" title="1">if len(tags) &gt; 0 </span><span class="cov8" title="1">{
                filter["tags"] = bson.M{"$in": tags}
        }</span>

        // Add status filter if provided
        <span class="cov8" title="1">if status != "" </span><span class="cov8" title="1">{
                filter["status"] = status
        }</span>

        // Set up options - sort by newest first
        <span class="cov8" title="1">opts := options.Find().SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.questionCollection.Find(context.TODO(), filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search questions: %v", err)
        }</span>
        <span class="cov8" title="1">defer cursor.Close(context.TODO())

        var questions []model.ForumQuestion
        if err = cursor.All(context.TODO(), &amp;questions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode search results: %v", err)
        }</span>

        <span class="cov8" title="1">return questions, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "context"
        "courses-service/src/model"
        "fmt"
        "sort"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type ModuleRepository struct {
        db               *mongo.Client
        dbName           string
        moduleCollection *mongo.Collection
}

func NewModuleRepository(db *mongo.Client, dbName string) *ModuleRepository <span class="cov8" title="1">{
        return &amp;ModuleRepository{db: db, dbName: dbName, moduleCollection: db.Database(dbName).Collection("courses")}
}</span>

func (r *ModuleRepository) GetNextModuleOrder(courseID string) (int, error) <span class="cov8" title="1">{
        var course model.Course
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid course ID: %v", err)
        }</span>
        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID}
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to find course: %v", err)
        }</span>

        <span class="cov8" title="1">maxOrder := 0
        for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.Order &gt; maxOrder </span><span class="cov8" title="1">{
                        maxOrder = module.Order
                }</span>
        }

        <span class="cov8" title="1">return maxOrder + 1, nil</span>
}

func (r *ModuleRepository) CreateModule(courseID string, module model.Module) (*model.Module, error) <span class="cov8" title="1">{
        module.ID = primitive.NewObjectID()

        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID}
        update := bson.M{"$push": bson.M{"modules": module}}

        var course model.Course
        err = r.moduleCollection.FindOneAndUpdate(context.TODO(), filter, update).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create module: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;module, nil</span>
}

// reorderModules adjusts the order of modules when a module's position changes
func (r *ModuleRepository) reorderModules(modules []model.Module, targetModuleID primitive.ObjectID, newOrder int, oldOrder int) <span class="cov8" title="1">{
        for i := range modules </span><span class="cov8" title="1">{
                if modules[i].ID == targetModuleID </span><span class="cov8" title="1">{
                        // This is the target module, set its new order
                        modules[i].Order = newOrder
                }</span> else<span class="cov8" title="1"> {
                        // Adjust order for other modules
                        currentOrder := modules[i].Order

                        if oldOrder &lt; newOrder </span><span class="cov0" title="0">{
                                // Module moved down: shift modules between oldOrder+1 and newOrder up
                                if currentOrder &gt; oldOrder &amp;&amp; currentOrder &lt;= newOrder </span><span class="cov0" title="0">{
                                        modules[i].Order = currentOrder - 1
                                }</span>
                        } else<span class="cov8" title="1"> if oldOrder &gt; newOrder </span><span class="cov8" title="1">{
                                // Module moved up: shift modules between newOrder and oldOrder-1 down
                                if currentOrder &gt;= newOrder &amp;&amp; currentOrder &lt; oldOrder </span><span class="cov8" title="1">{
                                        modules[i].Order = currentOrder + 1
                                }</span>
                        }
                }
        }
}

// updateModuleFields updates the non-order fields of a target module
func (r *ModuleRepository) updateModuleFields(modules []model.Module, targetModuleID primitive.ObjectID, updatedModule model.Module) <span class="cov8" title="1">{
        for i := range modules </span><span class="cov8" title="1">{
                if modules[i].ID == targetModuleID </span><span class="cov8" title="1">{
                        if updatedModule.Title != "" </span><span class="cov8" title="1">{
                                modules[i].Title = updatedModule.Title
                        }</span>
                        <span class="cov8" title="1">if updatedModule.Description != "" </span><span class="cov8" title="1">{
                                modules[i].Description = updatedModule.Description
                        }</span>
                        // Update Data field - explicit handling for slice
                        <span class="cov8" title="1">if updatedModule.Data != nil </span><span class="cov8" title="1">{
                                modules[i].Data = updatedModule.Data
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
}

func (r *ModuleRepository) UpdateModule(id string, module model.Module) (*model.Module, error) <span class="cov8" title="1">{
        moduleUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid module ID: %v", err)
        }</span>

        // First, get the current module and course to check if order has changed
        <span class="cov8" title="1">filter := bson.M{"modules._id": moduleUUID}
        var currentCourse model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;currentCourse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find module: %v", err)
        }</span>

        // Find the current module
        <span class="cov8" title="1">var currentModule *model.Module
        for _, mod := range currentCourse.Modules </span><span class="cov8" title="1">{
                if mod.ID == moduleUUID </span><span class="cov8" title="1">{
                        currentModule = &amp;mod
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentModule == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("module not found")
        }</span>

        // Check if order has changed
        <span class="cov8" title="1">if module.Order != 0 &amp;&amp; module.Order != currentModule.Order </span><span class="cov8" title="1">{
                // Update module fields first
                r.updateModuleFields(currentCourse.Modules, moduleUUID, module)

                // Reorder modules
                r.reorderModules(currentCourse.Modules, moduleUUID, module.Order, currentModule.Order)

                // Sort modules by order to maintain consistency
                sort.Slice(currentCourse.Modules, func(i, j int) bool </span><span class="cov8" title="1">{
                        return currentCourse.Modules[i].Order &lt; currentCourse.Modules[j].Order
                }</span>)

                // Update the entire course with reordered modules
                <span class="cov8" title="1">courseFilter := bson.M{"_id": currentCourse.ID}
                update := bson.M{"$set": bson.M{"modules": currentCourse.Modules}}

                _, err = r.moduleCollection.UpdateOne(context.TODO(), courseFilter, update)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update module order: %v", err)
                }</span>

                // Return the updated module
                <span class="cov8" title="1">for _, mod := range currentCourse.Modules </span><span class="cov8" title="1">{
                        if mod.ID == moduleUUID </span><span class="cov8" title="1">{
                                return &amp;mod, nil
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // No order change, just update the specific module fields
                updateFields := bson.M{}
                if module.Title != "" </span><span class="cov8" title="1">{
                        updateFields["modules.$.title"] = module.Title
                }</span>
                <span class="cov8" title="1">if module.Description != "" </span><span class="cov8" title="1">{
                        updateFields["modules.$.description"] = module.Description
                }</span>
                // Handle Data field update
                <span class="cov8" title="1">if module.Data != nil </span><span class="cov8" title="1">{
                        updateFields["modules.$.data"] = module.Data
                }</span>

                <span class="cov8" title="1">if len(updateFields) &gt; 0 </span><span class="cov8" title="1">{
                        update := bson.M{"$set": updateFields}
                        _, err = r.moduleCollection.UpdateOne(context.TODO(), filter, update)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update module: %v", err)
                        }</span>
                }

                // Get the updated course to return the module
                <span class="cov8" title="1">err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;currentCourse)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find updated module: %v", err)
                }</span>

                // Return the updated module
                <span class="cov8" title="1">for _, mod := range currentCourse.Modules </span><span class="cov8" title="1">{
                        if mod.ID == moduleUUID </span><span class="cov8" title="1">{
                                return &amp;mod, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module not found after update")</span>
}

func (r *ModuleRepository) DeleteModule(id string) error <span class="cov8" title="1">{
        moduleUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid module ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"modules._id": moduleUUID}
        update := bson.M{"$pull": bson.M{"modules": bson.M{"_id": moduleUUID}}}

        var course model.Course
        err = r.moduleCollection.FindOneAndUpdate(context.TODO(), filter, update).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete module: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ModuleRepository) GetModuleByName(courseID string, moduleName string) (*model.Module, error) <span class="cov8" title="1">{
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID, "modules.title": moduleName}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find course or module: %v", err)
        }</span>

        // Find the module with the specified name
        <span class="cov8" title="1">for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.Title == moduleName </span><span class="cov8" title="1">{
                        return &amp;module, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module with name %s not found in course %s", moduleName, courseID)</span>
}

func (r *ModuleRepository) GetModuleById(id string) (*model.Module, error) <span class="cov8" title="1">{
        moduleUUID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid module ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"modules._id": moduleUUID}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find course or module: %v", err)
        }</span>

        // Find the module with the specified ID
        <span class="cov8" title="1">for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.ID == moduleUUID </span><span class="cov8" title="1">{
                        return &amp;module, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module with ID %s not found", id)</span>
}

func (r *ModuleRepository) GetModulesByCourseId(courseID string) ([]model.Module, error) <span class="cov8" title="1">{
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find course: %v", err)
        }</span>

        // Sort modules by order before returning
        <span class="cov8" title="1">sort.Slice(course.Modules, func(i, j int) bool </span><span class="cov8" title="1">{
                return course.Modules[i].Order &lt; course.Modules[j].Order
        }</span>)

        <span class="cov8" title="1">return course.Modules, nil</span>
}

func (r *ModuleRepository) GetModuleByOrder(courseID string, order int) (*model.Module, error) <span class="cov8" title="1">{
        courseUUID, err := primitive.ObjectIDFromHex(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid course ID: %v", err)
        }</span>

        <span class="cov8" title="1">filter := bson.M{"_id": courseUUID, "modules.order": order}

        var course model.Course
        err = r.moduleCollection.FindOne(context.TODO(), filter).Decode(&amp;course)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find course: %v", err)
        }</span>

        <span class="cov8" title="1">for _, module := range course.Modules </span><span class="cov8" title="1">{
                if module.Order == order </span><span class="cov8" title="1">{
                        return &amp;module, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("module with order %d not found in course %s", order, courseID)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "context"

        "courses-service/src/model"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type MongoSubmissionRepository struct {
        collection *mongo.Collection
}

func NewMongoSubmissionRepository(db *mongo.Database) SubmissionRepositoryInterface <span class="cov8" title="1">{
        return &amp;MongoSubmissionRepository{
                collection: db.Collection("submissions"),
        }
}</span>

func (r *MongoSubmissionRepository) Create(ctx context.Context, submission *model.Submission) error <span class="cov8" title="1">{
        result, err := r.collection.InsertOne(ctx, submission)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">submission.ID = result.InsertedID.(primitive.ObjectID)
        return nil</span>
}

func (r *MongoSubmissionRepository) Update(ctx context.Context, submission *model.Submission) error <span class="cov8" title="1">{
        filter := bson.M{"_id": submission.ID}
        _, err := r.collection.ReplaceOne(ctx, filter, submission)
        return err
}</span>

func (r *MongoSubmissionRepository) GetByID(ctx context.Context, id string) (*model.Submission, error) <span class="cov8" title="1">{
        objectID, err := primitive.ObjectIDFromHex(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var submission model.Submission
        err = r.collection.FindOne(ctx, bson.M{"_id": objectID}).Decode(&amp;submission)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;submission, nil</span>
}

func (r *MongoSubmissionRepository) GetByAssignmentAndStudent(ctx context.Context, assignmentID, studentUUID string) (*model.Submission, error) <span class="cov8" title="1">{
        var submission model.Submission
        err := r.collection.FindOne(ctx, bson.M{
                "assignment_id": assignmentID,
                "student_uuid":  studentUUID,
        }).Decode(&amp;submission)
        if err != nil </span><span class="cov8" title="1">{
                if err == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;submission, nil</span>
}

func (r *MongoSubmissionRepository) GetByAssignment(ctx context.Context, assignmentID string) ([]model.Submission, error) <span class="cov8" title="1">{
        cursor, err := r.collection.Find(ctx, bson.M{"assignment_id": assignmentID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        var submissions []model.Submission = make([]model.Submission, 0)
        if err = cursor.All(ctx, &amp;submissions); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return submissions, nil</span>
}

func (r *MongoSubmissionRepository) GetByStudent(ctx context.Context, studentUUID string) ([]model.Submission, error) <span class="cov8" title="1">{
        cursor, err := r.collection.Find(ctx, bson.M{"student_uuid": studentUUID})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer cursor.Close(ctx)

        var submissions []model.Submission = make([]model.Submission, 0)
        if err = cursor.All(ctx, &amp;submissions); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return submissions, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package router

import (
        "courses-service/src/ai"
        "courses-service/src/config"
        "courses-service/src/controller"
        "courses-service/src/database"
        "courses-service/src/middleware"
        "courses-service/src/repository"
        "courses-service/src/service"
        "log"
        "log/slog"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"

        nrgin "github.com/newrelic/go-agent/v3/integrations/nrgin"
        "github.com/newrelic/go-agent/v3/newrelic"
)

func createRouterFromConfig(config *config.Config) *gin.Engine <span class="cov8" title="1">{
        if config.Environment == "production" </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span> else<span class="cov8" title="1"> {
                gin.SetMode(gin.DebugMode)
        }</span>

        <span class="cov8" title="1">r := gin.Default()
        return r</span>
}

func addNewRelicMiddleware(r *gin.Engine) <span class="cov8" title="1">{
        app, err := newrelic.NewApplication(
                newrelic.ConfigAppName("courses-service"),
                newrelic.ConfigLicense("35988c9ba24331e549191b23c94a4cb2FFFFNRAL"),
                newrelic.ConfigAppLogForwardingEnabled(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create NewRelic application: %v", err)
        }</span>

        <span class="cov8" title="1">r.Use(nrgin.Middleware(app))</span>
}

func InitializeCoursesRoutes(r *gin.Engine, controller *controller.CourseController) <span class="cov8" title="1">{
        r.GET("/courses", controller.GetCourses)
        r.POST("/courses", controller.CreateCourse)
        r.GET("/courses/teacher/:teacherId", controller.GetCourseByTeacherId)
        r.GET("/courses/student/:studentId", controller.GetCoursesByStudentId)
        r.GET("/courses/student/:studentId/favourite", controller.GetFavouriteCourses)
        r.GET("/courses/user/:userId", controller.GetCoursesByUserId)
        r.GET("/courses/title/:title", controller.GetCourseByTitle)
        r.GET("/courses/:id", controller.GetCourseById)
        r.GET("/courses/:id/members", controller.GetCourseMembers)
        r.DELETE("/courses/:id", controller.DeleteCourse)
        r.PUT("/courses/:id", controller.UpdateCourse)
        r.POST("/courses/:id/aux-teacher/add", controller.AddAuxTeacherToCourse)
        r.DELETE("/courses/:id/aux-teacher/remove", controller.RemoveAuxTeacherFromCourse)
        r.POST("/courses/:id/feedback", controller.CreateCourseFeedback)
        r.GET("/courses/:id/feedback", controller.GetCourseFeedback)
        r.GET("/courses/:id/feedback/summary", controller.GetCourseFeedbackSummary)
}</span>

func InitializeModulesRoutes(r *gin.Engine, controller *controller.ModuleController) <span class="cov8" title="1">{
        r.POST("/modules", controller.CreateModule)
        r.GET("/modules/course/:courseId", controller.GetModulesByCourseId)
        r.GET("/modules/:id", controller.GetModuleById)
        r.DELETE("/modules/:id", controller.DeleteModule)
        r.PUT("/modules/:id", controller.UpdateModule)
}</span>

func InitializeAssignmentsRoutes(r *gin.Engine, controller *controller.AssignmentsController) <span class="cov8" title="1">{
        r.GET("/assignments", controller.GetAssignments)
        r.POST("/assignments", controller.CreateAssignment)
        r.GET("/assignments/course/:courseId", controller.GetAssignmentsByCourseId)
        r.GET("/assignments/:assignmentId", controller.GetAssignmentById)
        r.PUT("/assignments/:assignmentId", controller.UpdateAssignment)
        r.DELETE("/assignments/:assignmentId", controller.DeleteAssignment)
}</span>

func InitializeSubmissionRoutes(r *gin.Engine, controller *controller.SubmissionController) <span class="cov8" title="1">{
        // Aplicar el middleware de autenticación de estudiantes
        studentAuthGroup := r.Group("")
        studentAuthGroup.Use(middleware.StudentAuth())

        studentAuthGroup.POST("/assignments/:assignmentId/submissions", controller.CreateSubmission)
        studentAuthGroup.GET("/assignments/:assignmentId/submissions/:id", controller.GetSubmission)
        studentAuthGroup.PUT("/assignments/:assignmentId/submissions/:id", controller.UpdateSubmission)
        studentAuthGroup.POST("/assignments/:assignmentId/submissions/:id/submit", controller.SubmitSubmission)
        studentAuthGroup.GET("/students/:studentUUID/submissions", controller.GetSubmissionsByStudent)

        // Aplicar el middleware de autenticación de docentes para calificar
        teacherAuthGroup := r.Group("")
        teacherAuthGroup.Use(middleware.TeacherAuth())
        teacherAuthGroup.PUT("/assignments/:assignmentId/submissions/:id/grade", controller.GradeSubmission)

        // Esta ruta no requiere autenticación de estudiante
        r.GET("/assignments/:assignmentId/submissions", controller.GetSubmissionsByAssignment)
}</span>

func InitializeEnrollmentsRoutes(r *gin.Engine, controller *controller.EnrollmentController) <span class="cov8" title="1">{
        r.GET("/courses/:id/enrollments", controller.GetEnrollmentsByCourseId)
        r.POST("/courses/:id/enroll", controller.EnrollStudent)
        r.DELETE("/courses/:id/unenroll", controller.UnenrollStudent)
        r.POST("/courses/:id/favourite", controller.SetFavouriteCourse)
        r.DELETE("/courses/:id/favourite", controller.UnsetFavouriteCourse)
        r.POST("/courses/:id/student-feedback", controller.CreateFeedback)
        r.GET("/feedback/student/:id", controller.GetFeedbackByStudentId)
        r.GET("/feedback/student/:id/summary", controller.GetStudentFeedbackSummary)
}</span>

func InitializeForumRoutes(r *gin.Engine, controller *controller.ForumController) <span class="cov8" title="1">{
        // Question endpoints
        r.POST("/forum/questions", controller.CreateQuestion)
        r.GET("/forum/questions/:questionId", controller.GetQuestionById)
        r.GET("/forum/courses/:courseId/questions", controller.GetQuestionsByCourseId)
        r.PUT("/forum/questions/:questionId", controller.UpdateQuestion)
        r.DELETE("/forum/questions/:questionId", controller.DeleteQuestion)

        // Answer endpoints
        r.POST("/forum/questions/:questionId/answers", controller.AddAnswer)
        r.PUT("/forum/questions/:questionId/answers/:answerId", controller.UpdateAnswer)
        r.DELETE("/forum/questions/:questionId/answers/:answerId", controller.DeleteAnswer)
        r.POST("/forum/questions/:questionId/answers/:answerId/accept", controller.AcceptAnswer)

        // Vote endpoints
        r.POST("/forum/questions/:questionId/vote", controller.VoteQuestion)
        r.POST("/forum/questions/:questionId/answers/:answerId/vote", controller.VoteAnswer)
        r.DELETE("/forum/questions/:questionId/vote", controller.RemoveVoteFromQuestion)
        r.DELETE("/forum/questions/:questionId/answers/:answerId/vote", controller.RemoveVoteFromAnswer)

        // Search endpoints
        r.GET("/forum/courses/:courseId/search", controller.SearchQuestions)
}</span>

func NewRouter(config *config.Config) *gin.Engine <span class="cov8" title="1">{
        r := createRouterFromConfig(config)
        addNewRelicMiddleware(r)

        slog.Debug("Connecting to database")

        dbClient, err := database.NewMongoDBClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>

        <span class="cov8" title="1">slog.Debug("Connected to database")

        aiClient := ai.NewAiClient(config)

        courseRepo := repository.NewCourseRepository(dbClient, config.DBName)
        enrollmentRepo := repository.NewEnrollmentRepository(dbClient, config.DBName, courseRepo)
        assignmentRepository := repository.NewAssignmentRepository(dbClient, config.DBName)
        submissionRepository := repository.NewMongoSubmissionRepository(dbClient.Database(config.DBName))
        moduleRepository := repository.NewModuleRepository(dbClient, config.DBName)
        forumRepository := repository.NewForumRepository(dbClient, config.DBName)

        courseService := service.NewCourseService(courseRepo, enrollmentRepo)
        enrollmentService := service.NewEnrollmentService(enrollmentRepo, courseRepo)
        assignmentService := service.NewAssignmentService(assignmentRepository, courseService)
        submissionService := service.NewSubmissionService(submissionRepository, assignmentRepository, courseService)
        moduleService := service.NewModuleService(moduleRepository)
        forumService := service.NewForumService(forumRepository, courseRepo)

        courseController := controller.NewCourseController(courseService, aiClient)
        enrollmentController := controller.NewEnrollmentController(enrollmentService, aiClient)
        assignmentsController := controller.NewAssignmentsController(assignmentService)
        submissionController := controller.NewSubmissionController(submissionService) // TODO change this when interface is added
        moduleController := controller.NewModuleController(moduleService)
        forumController := controller.NewForumController(forumService)

        InitializeRoutes(r, courseController, assignmentsController, submissionController, enrollmentController, moduleController, forumController)
        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler)) // endpoint to consult the swagger documentation
        return r</span>
}

func InitializeRoutes(
        r *gin.Engine,
        courseController *controller.CourseController,
        assignmentsController *controller.AssignmentsController,
        submissionController *controller.SubmissionController,
        enrollmentController *controller.EnrollmentController,
        moduleController *controller.ModuleController,
        forumController *controller.ForumController,
) <span class="cov8" title="1">{
        InitializeCoursesRoutes(r, courseController)
        InitializeSubmissionRoutes(r, submissionController)
        InitializeAssignmentsRoutes(r, assignmentsController)
        InitializeEnrollmentsRoutes(r, enrollmentController)
        InitializeModulesRoutes(r, moduleController)
        InitializeForumRoutes(r, forumController)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "context"
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "errors"
        "time"
)

type AssignmentService struct {
        assignmentRepository repository.AssignmentRepositoryInterface
        courseService        CourseServiceInterface
}

func NewAssignmentService(assignmentRepository repository.AssignmentRepositoryInterface, courseService CourseServiceInterface) *AssignmentService <span class="cov8" title="1">{
        return &amp;AssignmentService{assignmentRepository: assignmentRepository, courseService: courseService}
}</span>

func (s *AssignmentService) GetAssignments() ([]*model.Assignment, error) <span class="cov8" title="1">{
        return s.assignmentRepository.GetAssignments()
}</span>

func (s *AssignmentService) GetAssignmentById(id string) (*model.Assignment, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.assignmentRepository.GetByID(context.TODO(), id)</span>
}

func (s *AssignmentService) CreateAssignment(c schemas.CreateAssignmentRequest) (*model.Assignment, error) <span class="cov8" title="1">{
        // Validate course exists
        course, err := s.courseService.GetCourseById(c.CourseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course == nil </span><span class="cov8" title="1">{
                return nil, errors.New("course not found")
        }</span>

        <span class="cov8" title="1">assignment := model.Assignment{
                Title:        c.Title,
                Description:  c.Description,
                Instructions: c.Instructions,
                Type:         c.Type,
                CourseID:     c.CourseID,
                DueDate:      c.DueDate,
                GracePeriod:  c.GracePeriod,
                Status:       c.Status,
                Questions:    c.Questions,
                TotalPoints:  c.TotalPoints,
                PassingScore: c.PassingScore,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        return s.assignmentRepository.CreateAssignment(assignment)</span>
}

func (s *AssignmentService) UpdateAssignment(id string, updateAssignmentRequest schemas.UpdateAssignmentRequest) (*model.Assignment, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>

        // Check if assignment exists
        <span class="cov8" title="1">existingAssignment, err := s.assignmentRepository.GetByID(context.TODO(), id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if existingAssignment == nil </span><span class="cov8" title="1">{
                return nil, errors.New("assignment not found")
        }</span>

        <span class="cov8" title="1">assignment := model.Assignment{
                Title:        updateAssignmentRequest.Title,
                Description:  updateAssignmentRequest.Description,
                Instructions: updateAssignmentRequest.Instructions,
                Type:         updateAssignmentRequest.Type,
                CourseID:     existingAssignment.CourseID,
                DueDate:      updateAssignmentRequest.DueDate,
                GracePeriod:  updateAssignmentRequest.GracePeriod,
                Status:       updateAssignmentRequest.Status,
                Questions:    updateAssignmentRequest.Questions,
                TotalPoints:  updateAssignmentRequest.TotalPoints,
                PassingScore: updateAssignmentRequest.PassingScore,
                UpdatedAt:    time.Now(),
        }

        return s.assignmentRepository.UpdateAssignment(id, assignment)</span>
}

func (s *AssignmentService) DeleteAssignment(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.assignmentRepository.DeleteAssignment(id)</span>
}

func (s *AssignmentService) GetAssignmentsByCourseId(courseId string) ([]*model.Assignment, error) <span class="cov8" title="1">{
        if courseId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("course id is required")
        }</span>
        <span class="cov8" title="1">return s.assignmentRepository.GetAssignmentsByCourseId(courseId)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "errors"
        "slices"
        "time"
)

type CourseService struct {
        courseRepository     repository.CourseRepositoryInterface
        enrollmentRepository repository.EnrollmentRepositoryInterface
}

func NewCourseService(courseRepository repository.CourseRepositoryInterface, enrollmentRepository repository.EnrollmentRepositoryInterface) *CourseService <span class="cov8" title="1">{
        return &amp;CourseService{courseRepository: courseRepository, enrollmentRepository: enrollmentRepository}
}</span>

func (s *CourseService) GetCourses() ([]*model.Course, error) <span class="cov8" title="1">{
        return s.courseRepository.GetCourses()
}</span>

func (s *CourseService) CreateCourse(c schemas.CreateCourseRequest) (*model.Course, error) <span class="cov8" title="1">{
        if c.Capacity &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("capacity must be greater than 0")
        }</span>
        //TODO: check teacher exists
        <span class="cov8" title="1">course := model.Course{
                Title:       c.Title,
                Description: c.Description,
                TeacherUUID: c.TeacherID,
                Capacity:    c.Capacity,
                Modules:     []model.Module{},
                AuxTeachers: []string{},
                Feedback:    []model.CourseFeedback{},
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                StartDate:   c.StartDate,
                EndDate:     c.EndDate,
        }
        return s.courseRepository.CreateCourse(course)</span>
}

func (s *CourseService) GetCourseById(id string) (*model.Course, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCourseById(id)</span>
}

func (s *CourseService) DeleteCourse(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return errors.New("id is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.DeleteCourse(id)</span>
}

func (s *CourseService) GetCourseByTeacherId(teacherId string) ([]*model.Course, error) <span class="cov8" title="1">{
        if teacherId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("teacherId is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCourseByTeacherId(teacherId)</span>
}

func (s *CourseService) GetCoursesByStudentId(studentId string) ([]*model.Course, error) <span class="cov8" title="1">{
        if studentId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("studentId is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCoursesByStudentId(studentId)</span>
}

func (s *CourseService) GetCoursesByUserId(userId string) (*schemas.GetCoursesByUserIdResponse, error) <span class="cov8" title="1">{
        if userId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("userId is required")
        }</span>
        <span class="cov8" title="1">result := schemas.GetCoursesByUserIdResponse{}

        studentCourses, err := s.courseRepository.GetCoursesByStudentId(userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">teacherCourses, err := s.courseRepository.GetCourseByTeacherId(userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result.Student = studentCourses
        result.Teacher = teacherCourses

        return &amp;result, nil</span>
}

func (s *CourseService) GetCourseByTitle(title string) ([]*model.Course, error) <span class="cov8" title="1">{
        if title == "" </span><span class="cov8" title="1">{
                return nil, errors.New("title is required")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.GetCourseByTitle(title)</span>
}

func (s *CourseService) UpdateCourse(id string, updateCourseRequest schemas.UpdateCourseRequest) (*model.Course, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("id is required")
        }</span>
        <span class="cov8" title="1">course := model.Course{
                Title:       updateCourseRequest.Title,
                Description: updateCourseRequest.Description,
                TeacherUUID: updateCourseRequest.TeacherID,
                Capacity:    updateCourseRequest.Capacity,
                UpdatedAt:   time.Now(),
        }
        return s.courseRepository.UpdateCourse(id, course)</span>
}

func (s *CourseService) AddAuxTeacherToCourse(id string, titularTeacherId string, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID != titularTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the teacher trying to add an aux teacher is not the owner of the course")
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID == auxTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the titular teacher cannot be an aux teacher for his own course")
        }</span>
        <span class="cov8" title="1">if slices.Contains(course.AuxTeachers, auxTeacherId) </span><span class="cov8" title="1">{
                return nil, errors.New("aux teacher already exists")
        }</span>
        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(auxTeacherId, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if enrolled </span><span class="cov0" title="0">{
                return nil, errors.New("the aux teacher is already enrolled in the course")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.AddAuxTeacherToCourse(course, auxTeacherId)</span>
}

func (s *CourseService) RemoveAuxTeacherFromCourse(id string, titularTeacherId string, auxTeacherId string) (*model.Course, error) <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID != titularTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the teacher trying to remove an aux teacher is not the owner of the course")
        }</span>
        <span class="cov8" title="1">if course.TeacherUUID == auxTeacherId </span><span class="cov8" title="1">{
                return nil, errors.New("the titular teacher cannot be removed as aux teacher from his own course")
        }</span>
        <span class="cov8" title="1">if !slices.Contains(course.AuxTeachers, auxTeacherId) </span><span class="cov8" title="1">{
                return nil, errors.New("aux teacher is not assigned to this course")
        }</span>
        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(auxTeacherId, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if enrolled </span><span class="cov8" title="1">{
                return nil, errors.New("the aux teacher is already enrolled in the course")
        }</span>
        <span class="cov8" title="1">return s.courseRepository.RemoveAuxTeacherFromCourse(course, auxTeacherId)</span>
}

func (s *CourseService) GetFavouriteCourses(studentId string) ([]*model.Course, error) <span class="cov8" title="1">{
        if studentId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("studentId is required")
        }</span>

        <span class="cov8" title="1">enrollments, err := s.enrollmentRepository.GetEnrollmentsByStudentId(studentId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">courses, err := s.courseRepository.GetCoursesByStudentId(studentId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">favouriteCourses := make([]*model.Course, 0)

        for _, course := range courses </span><span class="cov8" title="1">{
                for _, enrollment := range enrollments </span><span class="cov8" title="1">{
                        if enrollment.CourseID == course.ID.Hex() &amp;&amp; enrollment.Favourite </span><span class="cov8" title="1">{
                                favouriteCourses = append(favouriteCourses, course)
                        }</span>
                }
        }
        <span class="cov8" title="1">return favouriteCourses, nil</span>
}

func (s *CourseService) CreateCourseFeedback(courseId string, feedbackRequest schemas.CreateCourseFeedbackRequest) (*model.CourseFeedback, error) <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(courseId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if feedbackRequest.Score &lt; 1 || feedbackRequest.Score &gt; 5 </span><span class="cov8" title="1">{
                return nil, errors.New("score must be between 1 and 5")
        }</span>

        // Check if the student is the teacher or an aux teacher (should not be allowed to give feedback)
        <span class="cov8" title="1">if course.TeacherUUID == feedbackRequest.StudentUUID || slices.Contains(course.AuxTeachers, feedbackRequest.StudentUUID) </span><span class="cov8" title="1">{
                return nil, errors.New("the teacher cannot give feedback to his own course")
        }</span>

        <span class="cov8" title="1">if enrolled, err := s.enrollmentRepository.IsEnrolled(feedbackRequest.StudentUUID, courseId); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span> else<span class="cov8" title="1"> if !enrolled </span><span class="cov8" title="1">{
                return nil, errors.New("the student is not enrolled in the course")
        }</span>

        <span class="cov8" title="1">feedback := model.CourseFeedback{
                StudentUUID:  feedbackRequest.StudentUUID,
                FeedbackType: feedbackRequest.FeedbackType,
                Score:        feedbackRequest.Score,
                Feedback:     feedbackRequest.Feedback,
                CreatedAt:    time.Now(),
        }

        return s.courseRepository.CreateCourseFeedback(courseId, feedback)</span>
}

func (s *CourseService) GetCourseFeedback(courseId string, getCourseFeedbackRequest schemas.GetCourseFeedbackRequest) ([]*model.CourseFeedback, error) <span class="cov8" title="1">{
        _, err := s.courseRepository.GetCourseById(courseId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("course not found: " + err.Error())
        }</span>

        <span class="cov8" title="1">feedback, err := s.courseRepository.GetCourseFeedback(courseId, getCourseFeedbackRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("error getting course feedback: " + err.Error())
        }</span>

        <span class="cov8" title="1">return feedback, nil</span>
}

func (s *CourseService) GetCourseMembers(courseId string) (*schemas.CourseMembersResponse, error) <span class="cov0" title="0">{
        if courseId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("courseId is required")
        }</span>

        // Get course to get teacher and aux teachers
        <span class="cov0" title="0">course, err := s.courseRepository.GetCourseById(courseId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get enrolled students
        <span class="cov0" title="0">enrollments, err := s.enrollmentRepository.GetEnrollmentsByCourseId(courseId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Extract student IDs from enrollments
        <span class="cov0" title="0">var studentIDs []string
        for _, enrollment := range enrollments </span><span class="cov0" title="0">{
                studentIDs = append(studentIDs, enrollment.StudentID)
        }</span>

        // Build response
        <span class="cov0" title="0">response := &amp;schemas.CourseMembersResponse{
                TeacherID:      course.TeacherUUID,
                AuxTeachersIDs: course.AuxTeachers,
                StudentsIDs:    studentIDs,
        }

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "fmt"
        "slices"
        "time"

        "go.mongodb.org/mongo-driver/mongo"
)

type EnrollmentService struct {
        enrollmentRepository repository.EnrollmentRepositoryInterface
        courseRepository     repository.CourseRepositoryInterface
}

func NewEnrollmentService(enrollmentRepository repository.EnrollmentRepositoryInterface, courseRepository repository.CourseRepositoryInterface) *EnrollmentService <span class="cov8" title="1">{
        return &amp;EnrollmentService{enrollmentRepository: enrollmentRepository, courseRepository: courseRepository}
}</span>

func (s *EnrollmentService) GetEnrollmentsByCourseId(courseID string) ([]*model.Enrollment, error) <span class="cov8" title="1">{
        if courseID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("course ID is required")
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("course %s not found", courseID)
        }</span>

        <span class="cov8" title="1">if course.StudentsAmount &lt;= 0 </span><span class="cov8" title="1">{
                return []*model.Enrollment{}, nil
        }</span>

        <span class="cov8" title="1">enrollments, err := s.enrollmentRepository.GetEnrollmentsByCourseId(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting enrollments by course ID: %v", err)
        }</span>

        <span class="cov8" title="1">return enrollments, nil</span>
}

func (s *EnrollmentService) EnrollStudent(studentID, courseID string) error <span class="cov8" title="1">{
        // First check if course exists
        course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for enrollment", courseID)
        }</span>

        // Then check if the course has the capacity to enroll more students
        <span class="cov8" title="1">if course.StudentsAmount &gt;= course.Capacity </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s is full", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot enroll in course %s", studentID, courseID)
        }</span>

        // Then check if the student is already enrolled in the course
        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is already enrolled in course %s", studentID, courseID)
        }</span>

        // Then create the enrollment
        <span class="cov8" title="1">enrollment := model.Enrollment{
                StudentID:  studentID,
                CourseID:   courseID,
                EnrolledAt: time.Now(),
                Status:     model.EnrollmentStatusActive,
                UpdatedAt:  time.Now(),
                Feedback:   []model.StudentFeedback{},
        }

        err = s.enrollmentRepository.CreateEnrollment(enrollment, course)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error creating enrollment for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) UnenrollStudent(studentID, courseID string) error <span class="cov8" title="1">{
        course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for unenrollment", courseID)
        }</span>

        <span class="cov8" title="1">if course.StudentsAmount &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s is empty", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot unenroll from course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil &amp;&amp; err != mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if !enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is not enrolled in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">err = s.enrollmentRepository.DeleteEnrollment(studentID, course)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error deleting enrollment for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) SetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        if studentID == "" || courseID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("student ID and course ID are required")
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for favourite course", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot set favourite course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if !enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is not enrolled in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">err = s.enrollmentRepository.SetFavouriteCourse(studentID, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error setting favourite course for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) UnsetFavouriteCourse(studentID, courseID string) error <span class="cov8" title="1">{
        if studentID == "" || courseID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("student ID and course ID are required")
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("course %s not found for unset favourite course", courseID)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID == studentID </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s cannot unset favourite course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">enrolled, err := s.enrollmentRepository.IsEnrolled(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error checking if student %s is enrolled in course %s", studentID, courseID)
        }</span>
        <span class="cov8" title="1">if !enrolled </span><span class="cov8" title="1">{
                return fmt.Errorf("student %s is not enrolled in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">err = s.enrollmentRepository.UnsetFavouriteCourse(studentID, courseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unsetting favourite course for student %s in course %s", studentID, courseID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) GetEnrollmentByStudentIdAndCourseId(studentID, courseID string) (*model.Enrollment, error) <span class="cov8" title="1">{
        if studentID == "" || courseID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("student ID and course ID are required")
        }</span>

        <span class="cov8" title="1">enrollment, err := s.enrollmentRepository.GetEnrollmentByStudentIdAndCourseId(studentID, courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting enrollment by student ID and course ID: %v", err)
        }</span>

        <span class="cov8" title="1">return enrollment, nil</span>
}

func (s *EnrollmentService) CreateStudentFeedback(feedbackRequest schemas.CreateStudentFeedbackRequest) error <span class="cov8" title="1">{
        if feedbackRequest.Score &lt; 1 || feedbackRequest.Score &gt; 5 </span><span class="cov8" title="1">{
                return fmt.Errorf("score must be between 1 and 5, not %d", feedbackRequest.Score)
        }</span>

        <span class="cov8" title="1">enrollment, err := s.GetEnrollmentByStudentIdAndCourseId(feedbackRequest.StudentUUID, feedbackRequest.CourseID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">course, err := s.courseRepository.GetCourseById(feedbackRequest.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting course by ID: %v", err)
        }</span>

        <span class="cov8" title="1">if course.TeacherUUID != feedbackRequest.TeacherUUID &amp;&amp; !slices.Contains(course.AuxTeachers, feedbackRequest.TeacherUUID) </span><span class="cov8" title="1">{
                return fmt.Errorf("teacher %s is not the teacher or aux teacher of course %s", feedbackRequest.TeacherUUID, feedbackRequest.CourseID)
        }</span>

        <span class="cov8" title="1">feedback := model.StudentFeedback{
                StudentUUID:  feedbackRequest.StudentUUID,
                TeacherUUID:  feedbackRequest.TeacherUUID,
                FeedbackType: feedbackRequest.FeedbackType,
                Score:        feedbackRequest.Score,
                Feedback:     feedbackRequest.Feedback,
                CreatedAt:    time.Now(),
        }

        err = s.enrollmentRepository.CreateStudentFeedback(feedback, enrollment.ID.Hex())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating student feedback: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *EnrollmentService) GetFeedbackByStudentId(studentID string, getFeedbackByStudentIdRequest schemas.GetFeedbackByStudentIdRequest) ([]*model.StudentFeedback, error) <span class="cov8" title="1">{
        if studentID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("student ID is required")
        }</span>

        <span class="cov8" title="1">feedback, err := s.enrollmentRepository.GetFeedbackByStudentId(studentID, getFeedbackByStudentIdRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting feedback by student ID: %v", err)
        }</span>

        <span class="cov8" title="1">return feedback, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "courses-service/src/model"
        "courses-service/src/repository"
        "errors"
        "slices"
)

type ForumService struct {
        forumRepository  repository.ForumRepositoryInterface
        courseRepository repository.CourseRepositoryInterface
}

func NewForumService(forumRepository repository.ForumRepositoryInterface, courseRepository repository.CourseRepositoryInterface) *ForumService <span class="cov8" title="1">{
        return &amp;ForumService{
                forumRepository:  forumRepository,
                courseRepository: courseRepository,
        }
}</span>

// Question operations

func (s *ForumService) CreateQuestion(courseID, authorID, title, description string, tags []model.QuestionTag) (*model.ForumQuestion, error) <span class="cov8" title="1">{
        // Validate required fields
        if courseID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("course ID is required")
        }</span>
        <span class="cov8" title="1">if authorID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("author ID is required")
        }</span>
        <span class="cov8" title="1">if title == "" </span><span class="cov8" title="1">{
                return nil, errors.New("title is required")
        }</span>
        <span class="cov8" title="1">if description == "" </span><span class="cov8" title="1">{
                return nil, errors.New("description is required")
        }</span>

        // Validate course exists
        <span class="cov8" title="1">_, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("course not found")
        }</span>

        // Validate tags
        <span class="cov8" title="1">if err := s.validateTags(tags); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">question := model.ForumQuestion{
                CourseID:    courseID,
                AuthorID:    authorID,
                Title:       title,
                Description: description,
                Tags:        tags,
        }

        return s.forumRepository.CreateQuestion(question)</span>
}

func (s *ForumService) GetQuestionById(id string) (*model.ForumQuestion, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("question ID is required")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.GetQuestionById(id)</span>
}

func (s *ForumService) GetQuestionsByCourseId(courseID string) ([]model.ForumQuestion, error) <span class="cov8" title="1">{
        if courseID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("course ID is required")
        }</span>

        // Validate course exists
        <span class="cov8" title="1">if _, err := s.courseRepository.GetCourseById(courseID); err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("course not found")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.GetQuestionsByCourseId(courseID)</span>
}

func (s *ForumService) UpdateQuestion(id, title, description string, tags []model.QuestionTag) (*model.ForumQuestion, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("question ID is required")
        }</span>

        // Get existing question to validate ownership later if needed
        <span class="cov8" title="1">existingQuestion, err := s.forumRepository.GetQuestionById(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate fields if provided
        <span class="cov8" title="1">if title == "" &amp;&amp; description == "" &amp;&amp; len(tags) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("at least one field must be provided for update")
        }</span>

        // Validate tags if provided
        <span class="cov8" title="1">if len(tags) &gt; 0 </span><span class="cov8" title="1">{
                if err := s.validateTags(tags); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">updateQuestion := model.ForumQuestion{
                Title:       title,
                Description: description,
                Tags:        tags,
        }

        // If only tags are being updated, preserve existing title and description
        if title == "" </span><span class="cov0" title="0">{
                updateQuestion.Title = existingQuestion.Title
        }</span>
        <span class="cov8" title="1">if description == "" </span><span class="cov0" title="0">{
                updateQuestion.Description = existingQuestion.Description
        }</span>
        <span class="cov8" title="1">if len(tags) == 0 </span><span class="cov0" title="0">{
                updateQuestion.Tags = existingQuestion.Tags
        }</span>

        <span class="cov8" title="1">return s.forumRepository.UpdateQuestion(id, updateQuestion)</span>
}

func (s *ForumService) DeleteQuestion(id, authorID string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return errors.New("question ID is required")
        }</span>
        <span class="cov8" title="1">if authorID == "" </span><span class="cov8" title="1">{
                return errors.New("author ID is required")
        }</span>

        // Validate question exists and check ownership
        <span class="cov8" title="1">question, err := s.forumRepository.GetQuestionById(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if question.AuthorID != authorID </span><span class="cov8" title="1">{
                return errors.New("you can only delete your own questions")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.DeleteQuestion(id)</span>
}

// Answer operations

func (s *ForumService) AddAnswer(questionID, authorID, content string) (*model.ForumAnswer, error) <span class="cov8" title="1">{
        if questionID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("question ID is required")
        }</span>
        <span class="cov8" title="1">if authorID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("author ID is required")
        }</span>
        <span class="cov8" title="1">if content == "" </span><span class="cov8" title="1">{
                return nil, errors.New("content is required")
        }</span>

        // Validate question exists
        <span class="cov8" title="1">_, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">answer := model.ForumAnswer{
                AuthorID: authorID,
                Content:  content,
        }

        return s.forumRepository.AddAnswer(questionID, answer)</span>
}

func (s *ForumService) UpdateAnswer(questionID, answerID, authorID, content string) (*model.ForumAnswer, error) <span class="cov8" title="1">{
        if questionID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("question ID is required")
        }</span>
        <span class="cov8" title="1">if answerID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("answer ID is required")
        }</span>
        <span class="cov8" title="1">if authorID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("author ID is required")
        }</span>
        <span class="cov8" title="1">if content == "" </span><span class="cov0" title="0">{
                return nil, errors.New("content is required")
        }</span>

        // Validate question exists and check answer ownership
        <span class="cov8" title="1">question, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Find the answer and check ownership
        <span class="cov8" title="1">var answerFound bool
        for _, answer := range question.Answers </span><span class="cov8" title="1">{
                if answer.ID == answerID </span><span class="cov8" title="1">{
                        if answer.AuthorID != authorID </span><span class="cov8" title="1">{
                                return nil, errors.New("you can only update your own answers")
                        }</span>
                        <span class="cov8" title="1">answerFound = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !answerFound </span><span class="cov0" title="0">{
                return nil, errors.New("answer not found")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.UpdateAnswer(questionID, answerID, content)</span>
}

func (s *ForumService) DeleteAnswer(questionID, answerID, authorID string) error <span class="cov8" title="1">{
        if questionID == "" </span><span class="cov0" title="0">{
                return errors.New("question ID is required")
        }</span>
        <span class="cov8" title="1">if answerID == "" </span><span class="cov0" title="0">{
                return errors.New("answer ID is required")
        }</span>
        <span class="cov8" title="1">if authorID == "" </span><span class="cov0" title="0">{
                return errors.New("author ID is required")
        }</span>

        // Validate question exists and check answer ownership
        <span class="cov8" title="1">question, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Find the answer and check ownership
        <span class="cov8" title="1">var answerFound bool
        for _, answer := range question.Answers </span><span class="cov8" title="1">{
                if answer.ID == answerID </span><span class="cov8" title="1">{
                        if answer.AuthorID != authorID </span><span class="cov8" title="1">{
                                return errors.New("you can only delete your own answers")
                        }</span>
                        <span class="cov8" title="1">answerFound = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !answerFound </span><span class="cov0" title="0">{
                return errors.New("answer not found")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.DeleteAnswer(questionID, answerID)</span>
}

func (s *ForumService) AcceptAnswer(questionID, answerID, authorID string) error <span class="cov8" title="1">{
        if questionID == "" </span><span class="cov0" title="0">{
                return errors.New("question ID is required")
        }</span>
        <span class="cov8" title="1">if answerID == "" </span><span class="cov0" title="0">{
                return errors.New("answer ID is required")
        }</span>
        <span class="cov8" title="1">if authorID == "" </span><span class="cov0" title="0">{
                return errors.New("author ID is required")
        }</span>

        // Validate question exists and check question ownership
        <span class="cov8" title="1">question, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if question.AuthorID != authorID </span><span class="cov8" title="1">{
                return errors.New("only the question author can accept answers")
        }</span>

        // Validate answer exists
        <span class="cov8" title="1">var answerFound bool
        for _, answer := range question.Answers </span><span class="cov8" title="1">{
                if answer.ID == answerID </span><span class="cov8" title="1">{
                        answerFound = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !answerFound </span><span class="cov0" title="0">{
                return errors.New("answer not found")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.AcceptAnswer(questionID, answerID)</span>
}

// Vote operations

func (s *ForumService) VoteQuestion(questionID, userID string, voteType int) error <span class="cov8" title="1">{
        if questionID == "" </span><span class="cov0" title="0">{
                return errors.New("question ID is required")
        }</span>
        <span class="cov8" title="1">if userID == "" </span><span class="cov0" title="0">{
                return errors.New("user ID is required")
        }</span>
        <span class="cov8" title="1">if voteType != model.VoteTypeUp &amp;&amp; voteType != model.VoteTypeDown </span><span class="cov0" title="0">{
                return errors.New("invalid vote type")
        }</span>

        // Validate question exists
        <span class="cov8" title="1">question, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if user is voting on their own question
        <span class="cov8" title="1">if question.AuthorID == userID </span><span class="cov8" title="1">{
                return errors.New("you cannot vote on your own question")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.AddVoteToQuestion(questionID, userID, voteType)</span>
}

func (s *ForumService) VoteAnswer(questionID, answerID, userID string, voteType int) error <span class="cov8" title="1">{
        if questionID == "" </span><span class="cov0" title="0">{
                return errors.New("question ID is required")
        }</span>
        <span class="cov8" title="1">if answerID == "" </span><span class="cov0" title="0">{
                return errors.New("answer ID is required")
        }</span>
        <span class="cov8" title="1">if userID == "" </span><span class="cov0" title="0">{
                return errors.New("user ID is required")
        }</span>
        <span class="cov8" title="1">if voteType != model.VoteTypeUp &amp;&amp; voteType != model.VoteTypeDown </span><span class="cov0" title="0">{
                return errors.New("invalid vote type")
        }</span>

        // Validate question and answer exist
        <span class="cov8" title="1">question, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Find the answer and check if user is voting on their own answer
        <span class="cov8" title="1">var answerFound bool
        for _, answer := range question.Answers </span><span class="cov8" title="1">{
                if answer.ID == answerID </span><span class="cov8" title="1">{
                        if answer.AuthorID == userID </span><span class="cov8" title="1">{
                                return errors.New("you cannot vote on your own answer")
                        }</span>
                        <span class="cov8" title="1">answerFound = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !answerFound </span><span class="cov0" title="0">{
                return errors.New("answer not found")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.AddVoteToAnswer(questionID, answerID, userID, voteType)</span>
}

func (s *ForumService) RemoveVoteFromQuestion(questionID, userID string) error <span class="cov0" title="0">{
        if questionID == "" </span><span class="cov0" title="0">{
                return errors.New("question ID is required")
        }</span>
        <span class="cov0" title="0">if userID == "" </span><span class="cov0" title="0">{
                return errors.New("user ID is required")
        }</span>

        // Validate question exists
        <span class="cov0" title="0">_, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.forumRepository.RemoveVoteFromQuestion(questionID, userID)</span>
}

func (s *ForumService) RemoveVoteFromAnswer(questionID, answerID, userID string) error <span class="cov0" title="0">{
        if questionID == "" </span><span class="cov0" title="0">{
                return errors.New("question ID is required")
        }</span>
        <span class="cov0" title="0">if answerID == "" </span><span class="cov0" title="0">{
                return errors.New("answer ID is required")
        }</span>
        <span class="cov0" title="0">if userID == "" </span><span class="cov0" title="0">{
                return errors.New("user ID is required")
        }</span>

        // Validate question and answer exist
        <span class="cov0" title="0">question, err := s.forumRepository.GetQuestionById(questionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Find the answer
        <span class="cov0" title="0">var answerFound bool
        for _, answer := range question.Answers </span><span class="cov0" title="0">{
                if answer.ID == answerID </span><span class="cov0" title="0">{
                        answerFound = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !answerFound </span><span class="cov0" title="0">{
                return errors.New("answer not found")
        }</span>

        <span class="cov0" title="0">return s.forumRepository.RemoveVoteFromAnswer(questionID, answerID, userID)</span>
}

// Search and filter operations

func (s *ForumService) SearchQuestions(courseID, query string, tags []model.QuestionTag, status model.QuestionStatus) ([]model.ForumQuestion, error) <span class="cov8" title="1">{
        if courseID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("course ID is required")
        }</span>

        // Validate course exists
        <span class="cov8" title="1">_, err := s.courseRepository.GetCourseById(courseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("course not found")
        }</span>

        // Validate tags if provided
        <span class="cov8" title="1">if len(tags) &gt; 0 </span><span class="cov8" title="1">{
                if err := s.validateTags(tags); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Validate status if provided
        <span class="cov8" title="1">if status != "" &amp;&amp; !s.isValidStatus(status) </span><span class="cov0" title="0">{
                return nil, errors.New("invalid question status")
        }</span>

        <span class="cov8" title="1">return s.forumRepository.SearchQuestions(courseID, query, tags, status)</span>
}

// Helper methods

func (s *ForumService) validateTags(tags []model.QuestionTag) error <span class="cov8" title="1">{
        if len(tags) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, tag := range tags </span><span class="cov8" title="1">{
                if !slices.Contains(model.QuestionTagValues, tag) </span><span class="cov8" title="1">{
                        return errors.New("invalid tag: " + string(tag))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *ForumService) isValidStatus(status model.QuestionStatus) bool <span class="cov8" title="1">{
        return slices.Contains(model.QuestionStatusValues, status)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "courses-service/src/model"
        "courses-service/src/repository"
        "courses-service/src/schemas"
        "errors"
        "fmt"
        "log/slog"
)

type ModuleService struct {
        moduleRepository repository.ModuleRepositoryInterface
}

func NewModuleService(moduleRepository repository.ModuleRepositoryInterface) *ModuleService <span class="cov8" title="1">{
        return &amp;ModuleService{moduleRepository: moduleRepository}
}</span>

func (s *ModuleService) CreateModule(module schemas.CreateModuleRequest) (*model.Module, error) <span class="cov8" title="1">{
        fmt.Printf("Creating module: %v\n", module)
        if _, err := s.moduleRepository.GetModuleByName(module.CourseID, module.Title); err == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("module with title %s already exists in course %s", module.Title, module.CourseID)
        }</span>

        <span class="cov8" title="1">moduleModel := model.Module{
                Title:       module.Title,
                Description: module.Description,
                Data:        []model.ModuleData{},
        }

        order, err := s.moduleRepository.GetNextModuleOrder(module.CourseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">moduleModel.Order = order

        return s.moduleRepository.CreateModule(module.CourseID, moduleModel)</span>
}

func (s *ModuleService) GetModulesByCourseId(courseId string) ([]model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Getting modules by course id", "courseId", courseId)
        if courseId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("courseId is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.GetModulesByCourseId(courseId)</span>
}

func (s *ModuleService) GetModuleById(id string) (*model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Getting module by id", "id", id)
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("module id is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.GetModuleById(id)</span>
}

func (s *ModuleService) GetModuleByOrder(courseID string, order int) (*model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Getting module by order", "courseID", courseID, "order", order)
        if courseID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("courseId is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.GetModuleByOrder(courseID, order)</span>
}
func (s *ModuleService) UpdateModule(id string, module model.Module) (*model.Module, error) <span class="cov8" title="1">{
        slog.Debug("Updating module", "id", id, "module", module)
        if id == "" </span><span class="cov8" title="1">{
                return nil, errors.New("module id is required")
        }</span>

        <span class="cov8" title="1">existingModule, err := s.moduleRepository.GetModuleByName(module.CourseID, module.Title)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check if the module we are updating is the same as the existing module
        <span class="cov8" title="1">if existingModule.ID != module.ID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("module with title %s already exists in course %s", module.Title, module.CourseID)
        }</span>

        <span class="cov8" title="1">return s.moduleRepository.UpdateModule(id, module)</span>
}

func (s *ModuleService) DeleteModule(id string) error <span class="cov8" title="1">{
        slog.Debug("Deleting module", "id", id)
        if id == "" </span><span class="cov8" title="1">{
                return errors.New("module id is required")
        }</span>
        <span class="cov8" title="1">return s.moduleRepository.DeleteModule(id)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package service

import (
        "context"
        "errors"
        "time"

        "courses-service/src/model"
        "courses-service/src/repository"
)

type SubmissionService struct {
        submissionRepo repository.SubmissionRepositoryInterface
        assignmentRepo repository.AssignmentRepositoryInterface
        courseService  CourseServiceInterface
}

func NewSubmissionService(submissionRepo repository.SubmissionRepositoryInterface, assignmentRepo repository.AssignmentRepositoryInterface, courseService CourseServiceInterface) *SubmissionService <span class="cov8" title="1">{
        return &amp;SubmissionService{
                submissionRepo: submissionRepo,
                assignmentRepo: assignmentRepo,
                courseService:  courseService,
        }
}</span>

func (s *SubmissionService) CreateSubmission(ctx context.Context, submission *model.Submission) error <span class="cov8" title="1">{
        // Get assignment to validate submission
        assignment, err := s.assignmentRepo.GetByID(ctx, submission.AssignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if assignment == nil </span><span class="cov8" title="1">{
                return ErrAssignmentNotFound
        }</span>

        // Initialize submission
        <span class="cov8" title="1">submission.CreatedAt = time.Now()
        submission.UpdatedAt = submission.CreatedAt
        submission.Status = model.SubmissionStatusDraft

        return s.submissionRepo.Create(ctx, submission)</span>
}

func (s *SubmissionService) UpdateSubmission(ctx context.Context, submission *model.Submission) error <span class="cov0" title="0">{
        existing, err := s.submissionRepo.GetByID(ctx, submission.ID.Hex())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if existing == nil </span><span class="cov0" title="0">{
                return ErrSubmissionNotFound
        }</span>

        <span class="cov0" title="0">submission.UpdatedAt = time.Now()
        return s.submissionRepo.Update(ctx, submission)</span>
}

func (s *SubmissionService) SubmitSubmission(ctx context.Context, submissionID string) error <span class="cov0" title="0">{
        submission, err := s.submissionRepo.GetByID(ctx, submissionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if submission == nil </span><span class="cov0" title="0">{
                return ErrSubmissionNotFound
        }</span>

        <span class="cov0" title="0">assignment, err := s.assignmentRepo.GetByID(ctx, submission.AssignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if assignment == nil </span><span class="cov0" title="0">{
                return ErrAssignmentNotFound
        }</span>

        <span class="cov0" title="0">now := time.Now()
        submission.SubmittedAt = &amp;now
        submission.UpdatedAt = now

        // Check if submission is late
        if now.After(assignment.DueDate) </span><span class="cov0" title="0">{
                gracePeriodEnd := assignment.DueDate.Add(time.Duration(assignment.GracePeriod) * time.Minute)
                if now.After(gracePeriodEnd) </span><span class="cov0" title="0">{
                        submission.Status = model.SubmissionStatusLate
                }</span>
        } else<span class="cov0" title="0"> {
                submission.Status = model.SubmissionStatusSubmitted
        }</span>

        <span class="cov0" title="0">return s.submissionRepo.Update(ctx, submission)</span>
}

func (s *SubmissionService) GetSubmission(ctx context.Context, id string) (*model.Submission, error) <span class="cov8" title="1">{
        return s.submissionRepo.GetByID(ctx, id)
}</span>

func (s *SubmissionService) GetSubmissionsByAssignment(ctx context.Context, assignmentID string) ([]model.Submission, error) <span class="cov0" title="0">{
        return s.submissionRepo.GetByAssignment(ctx, assignmentID)
}</span>

func (s *SubmissionService) GetSubmissionsByStudent(ctx context.Context, studentUUID string) ([]model.Submission, error) <span class="cov0" title="0">{
        return s.submissionRepo.GetByStudent(ctx, studentUUID)
}</span>

func (s *SubmissionService) GetOrCreateSubmission(ctx context.Context, assignmentID, studentUUID, studentName string) (*model.Submission, error) <span class="cov8" title="1">{
        submission, err := s.submissionRepo.GetByAssignmentAndStudent(ctx, assignmentID, studentUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if submission != nil </span><span class="cov8" title="1">{
                return submission, nil
        }</span>

        // Create new submission
        <span class="cov8" title="1">newSubmission := &amp;model.Submission{
                AssignmentID: assignmentID,
                StudentUUID:  studentUUID,
                StudentName:  studentName,
                Status:       model.SubmissionStatusDraft,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        err = s.submissionRepo.Create(ctx, newSubmission)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return newSubmission, nil</span>
}

// GradeSubmission updates the score and feedback of a submission
func (s *SubmissionService) GradeSubmission(ctx context.Context, submissionID string, score *float64, feedback string) (*model.Submission, error) <span class="cov8" title="1">{
        submission, err := s.submissionRepo.GetByID(ctx, submissionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if submission == nil </span><span class="cov8" title="1">{
                return nil, ErrSubmissionNotFound
        }</span>

        // Update submission with grading information
        <span class="cov8" title="1">submission.Score = score
        submission.Feedback = feedback
        submission.UpdatedAt = time.Now()

        err = s.submissionRepo.Update(ctx, submission)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return submission, nil</span>
}

// ValidateTeacherPermissions validates if a teacher can grade submissions for a given assignment
func (s *SubmissionService) ValidateTeacherPermissions(ctx context.Context, assignmentID, teacherUUID string) error <span class="cov8" title="1">{
        // Get assignment
        assignment, err := s.assignmentRepo.GetByID(ctx, assignmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if assignment == nil </span><span class="cov8" title="1">{
                return ErrAssignmentNotFound
        }</span>

        // Get course
        <span class="cov8" title="1">course, err := s.courseService.GetCourseById(assignment.CourseID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if course == nil </span><span class="cov0" title="0">{
                return errors.New("course not found")
        }</span>

        // Check if teacher is the main teacher
        <span class="cov8" title="1">if course.TeacherUUID == teacherUUID </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check if teacher is an auxiliary teacher
        <span class="cov8" title="1">for _, auxTeacher := range course.AuxTeachers </span><span class="cov8" title="1">{
                if auxTeacher == teacherUUID </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return errors.New("teacher not authorized to grade this assignment")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package testutil

import (
        "context"
        "log"
        "os"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// DBSetup holds the MongoDB client and database name for testing
type DBSetup struct {
        Client *mongo.Client
        DBName string
}

// SetupTestDB initializes a MongoDB client for testing
func SetupTestDB() *DBSetup <span class="cov8" title="1">{
        ctx := context.Background()
        uri := os.Getenv("DB_URI")
        clientOptions := options.Client().ApplyURI(uri)
        client, err := mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">err = client.Ping(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">dbName := os.Getenv("DB_NAME")
        log.Printf("Initialized test database %s running on %s", dbName, uri)

        return &amp;DBSetup{
                Client: client,
                DBName: dbName,
        }</span>
}

// CleanupTestDB disconnects from the MongoDB client
func CleanupTestDB(client *mongo.Client) <span class="cov0" title="0">{
        if err := client.Disconnect(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error disconnecting from database: %v", err)
        }</span>
}

// CleanupCollection drops all documents from a collection
func (db *DBSetup) CleanupCollection(collection string) <span class="cov8" title="1">{
        coll := db.Client.Database(db.DBName).Collection(collection)
        _, err := coll.DeleteMany(context.Background(), bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error cleaning up collection %s: %v", collection, err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
